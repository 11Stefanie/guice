<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<HEAD>
<meta name="generator" content="JDiff v1.1.1">
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<meta name="description" content="JDiff is a Javadoc doclet which generates an HTML report of all the packages, classes, constructors, methods, and fields which have been removed, added or changed in any way, including their documentation, when two APIs are compared.">
<meta name="keywords" content="diff, jdiff, javadiff, java diff, java difference, API difference, difference between two APIs, API diff, Javadoc, doclet">
<LINK REL="stylesheet" TYPE="text/css" HREF="../stylesheet-jdiff.css" TITLE="Style">
<TITLE>
com.google.inject.servlet Documentation Differences
</TITLE>
</HEAD>
<BODY>
<!-- Start of nav bar -->
<TABLE summary="Navigation bar" BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
  <TABLE summary="Navigation bar" BORDER="0" CELLPADDING="0" CELLSPACING="3">
    <TR ALIGN="center" VALIGN="top">
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/package-summary.html" target="_top"><FONT CLASS="NavBarFont1"><B><tt>latest</tt></B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="changes-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
      <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="docdiffs_index.html"><FONT CLASS="NavBarFont1"><B>Text Changes</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_statistics.html"><FONT CLASS="NavBarFont1"><B>Statistics</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_help.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
    </TR>
  </TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM><b>Generated by<br><a href="http://www.jdiff.org" class="staysblack" target="_top">JDiff</a></b></EM></TD>
</TR>
<TR>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="docdiffs_com.google.inject.persist.jpa.html"><B>PREV PACKAGE</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.spi.html"><B>NEXT PACKAGE</B></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <A HREF="../changes.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.servlet.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2">&nbsp;</TD>
</TR>
</TABLE>
<HR>
<!-- End of nav bar -->
<h2>
com.google.inject.servlet Documentation Differences
</h2>

<blockquote>
This file contains all the changes in documentation in the package <code>com.google.inject.servlet</code> as colored differences.
Deletions are shown <strike>like this</strike>, and
additions are shown <span style="background: #FFFF00">like this</span>.
</blockquote>
<blockquote>
If no deletions or additions are shown in an entry, the HTML tags will be what has changed. The <i>new</i> HTML tags are shown in the differences. 
If no documentation existed, and then some was added in a later version, this change is noted in the appropriate class pages of differences, but the change is not shown on this page. Only changes in existing text are shown here. 
Similarly, documentation which was inherited from another class or interface is not shown here.
</blockquote>
<blockquote>
 Note that an HTML error in the new documentation may cause the display of other documentation changes to be presented incorrectly. For instance, failure to close a &lt;code&gt; tag will cause all subsequent paragraphs to be displayed differently.
</blockquote>
<hr>

<A NAME="com.google.inject.servlet.GuiceFilter!class"></A><a href="com.google.inject.servlet.GuiceFilter.html" class="hiddenlink">Class <b>GuiceFilter</b></a><br><br><blockquote><strike>
 </strike>Apply this filter in web.xml above all other filters (typically), to all requests where you plan
 <strike> </strike>to use servlet scopes. This is also needed in order to dispatch requests to injectable filters
 <strike> </strike>and servlets:<strike>
 </strike><span style="background: #FFFF00">

</span> <pre>
  &lt;filter&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;filter-class&gt;<b>com.google.inject.servlet.GuiceFilter</b>&lt;/filter-class&gt;
  &lt;/filter&gt;

  &lt;filter-mapping&gt;
    &lt;filter-name&gt;guiceFilter&lt;/filter-name&gt;
    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;
  &lt;/filter-mapping&gt;
  </pre>

 This filter must appear before every filter that makes use of Guice injection or <strike>servlet
 scopes</strike><span style="background: #FFFF00">servlet scopes
</span> functionality. Typically, you will only register this filter in web.xml and <strike>register
</strike><span style="background: #FFFF00">register</span> any <strike>other</strike><span style="background: #FFFF00">other
</span> filters (and servlets) using a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/GuiceFilter/ServletModule.html"><TT>ServletModule</TT></A>.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.GuiceServletContextListener!class"></A><a href="com.google.inject.servlet.GuiceServletContextListener.html" class="hiddenlink">Class <b>GuiceServletContextListener</b></a><br><br><blockquote>As of Guice 2.0 you can still use (your subclasses of) {@code GuiceServletContextListener}<strike>
</strike> <strike>class</strike><span style="background: #FFFF00">class
</span> as a logical place to create and configure your injector. This will ensure the <strike>injector
</strike><span style="background: #FFFF00">injector</span> <strike>is</strike><span style="background: #FFFF00">is
</span> created when the web application is deployed.<strike>
 
</strike><span style="background: #FFFF00">

</span> @author Kevin Bourrillion (kevinb@google.com)
 @since 2.0</blockquote>
<A NAME="com.google.inject.servlet.GuiceServletContextListener.dmethod.getInjector()"></A><a href="com.google.inject.servlet.GuiceServletContextListener.html" class="hiddenlink">Class <b>GuiceServletContextListener</b></a>, <a href="com.google.inject.servlet.GuiceServletContextListener.html#com.google.inject.servlet.GuiceServletContextListener.getInjector_changed()" class="hiddenlink">Injector <b>getInjector()</b></a><br><br><blockquote>Override this method to create (or otherwise obtain a reference to) <strike>your
</strike><span style="background: #FFFF00">your</span> injector.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.InstanceFilterBinding!class"></A><a href="com.google.inject.servlet.InstanceFilterBinding.html" class="hiddenlink">Class <b>InstanceFilterBinding</b></a><br><br><blockquote>A binding to a single instance of a filter.<strike> </strike>

 @author sameb@google.com
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.InstanceServletBinding!class"></A><a href="com.google.inject.servlet.InstanceServletBinding.html" class="hiddenlink">Class <b>InstanceServletBinding</b></a><br><br><blockquote>A binding to a single instance of a servlet.<strike> </strike>

 @author sameb@google.com
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.LinkedFilterBinding!class"></A><a href="com.google.inject.servlet.LinkedFilterBinding.html" class="hiddenlink">Class <b>LinkedFilterBinding</b></a><br><br><blockquote>A linked binding to a filter.<strike> </strike>

 @author sameb@google.com
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.LinkedServletBinding!class"></A><a href="com.google.inject.servlet.LinkedServletBinding.html" class="hiddenlink">Class <b>LinkedServletBinding</b></a><br><br><blockquote>A linked binding to a servlet.<strike> </strike>

 @author sameb@google.com
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.RequestParameters!class"></A><a href="com.google.inject.servlet.RequestParameters.html" class="hiddenlink">Class <b>RequestParameters</b></a><br><br><blockquote>Apply this to field or parameters of type {@code Map<String, String[]>}<strike>
</strike> when you want the <strike>HTTP</strike><span style="background: #FFFF00">HTTP
</span> request parameter map to be injected.

 @author crazybob@google.com (Bob Lee)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.RequestScoper.dmethod.open()"></A><a href="com.google.inject.servlet.RequestScoper.html" class="hiddenlink">Class <b>RequestScoper</b></a>, <a href="com.google.inject.servlet.RequestScoper.html#com.google.inject.servlet.RequestScoper.open_changed()" class="hiddenlink">CloseableScope <b>open()</b></a><br><br><blockquote>Opens up the request scope until the returned object is closed.<strike>
</strike> Implementations should <strike>ensure</strike><span style="background: #FFFF00">ensure
</span> (e.g. by blocking) that multiple <strike>threads
</strike><span style="background: #FFFF00">threads</span> cannot open the same request scope concurrently. It <strike>is</strike><span style="background: #FFFF00">is
</span> allowable to <strike>open
</strike><span style="background: #FFFF00">open</span> the same request scope on the same thread, as long as open/close calls are
 correctly nested.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.ScopingOnly!class"></A><a href="com.google.inject.servlet.ScopingOnly.html" class="hiddenlink">Class <b>ScopingOnly</b></a><br><br><blockquote>Annotates a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ScopingOnly/GuiceFilter.html"><TT>GuiceFilter</TT></A> that provides scope functionality, <strike>but
</strike><span style="background: #FFFF00">but</span> doesn't dispatch to <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ScopingOnly/ServletModule.html"><TT>ServletModule</TT></A> bound servlets or filters.

 @author iqshum@google.com (Isaac Shum)
 @since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.ServletModule!class"></A><a href="com.google.inject.servlet.ServletModule.html" class="hiddenlink">Class <b>ServletModule</b></a><br><br><blockquote>Configures the servlet scopes and creates bindings for the servlet <strike>API
</strike><span style="background: #FFFF00">API</span> objects so you can <strike>inject</strike><span style="background: #FFFF00">inject
</span> the request, response, session, etc.

 <p><strike>
 </strike>You should subclass this module to register servlets <strike>and
</strike><span style="background: #FFFF00">and</span> filters in the <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ServletModule/.html#configureServlets()"><TT>.configureServlets()</TT></A> method.

 @author crazybob@google.com (Bob Lee)
 @author dhanji@gmail.com (Dhanji R. Prasanna)</blockquote>
<A NAME="com.google.inject.servlet.ServletModule.dmethod.configureServlets()"></A><a href="com.google.inject.servlet.ServletModule.html" class="hiddenlink">Class <b>ServletModule</b></a>, <a href="com.google.inject.servlet.ServletModule.html#com.google.inject.servlet.ServletModule.configureServlets_changed()" class="hiddenlink">void <b>configureServlets()</b></a><br><br><blockquote><h3>Servlet Mapping EDSL</h3>

 <p><strike> </strike>Part of the EDSL builder language for configuring <strike>servlets
</strike><span style="background: #FFFF00">servlets</span> and filters with guice-servlet.<span style="background: #FFFF00">
</span> Think of this as an in-code replacement for web.xml.<strike>
</strike> Filters and servlets are configured <strike>here</strike><span style="background: #FFFF00">here
</span> using simple java method calls. Here is a <strike>typical
</strike><span style="background: #FFFF00">typical</span> example of registering a filter when <strike>creating</strike><span style="background: #FFFF00">creating
</span> your Guice injector:

 <pre>
   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       <b>serve("*.html").with(MyServlet.class)</b>
     }
   }
 </pre>

 This registers a servlet (subclass of {@code HttpServlet}) called {@code MyServlet} to service
 any web pages ending in {@code .html}. You can also use a path-style syntax to register
 servlets:

 <pre>
       <b>serve("/my/*").with(MyServlet.class)</b>
 </pre>

 Every servlet (or filter) is required to be a singleton. If you cannot annotate the class
 directly, you should add a separate {@code bind(..).in(Singleton.class)} rule elsewhere <strike>in
</strike><span style="background: #FFFF00">in</span> <strike>your</strike><span style="background: #FFFF00">your
</span> module. Mapping a servlet that is bound under any other scope is an error.

 <p><strike>
</strike><span style="background: #FFFF00">

</span> <h4>Dispatch Order</h4><strike>
</strike><span style="background: #FFFF00">

</span> You are free to register as many servlets and filters as you like this way. They <strike>will
</strike><span style="background: #FFFF00">will</span> <strike>be</strike><span style="background: #FFFF00">be
</span> compared and dispatched in the order in which the filter methods are called:

 <pre>

   Guice.createInjector(..., new ServletModule() {

     {@literal @}Override
     protected void configureServlets() {
       filter("/*").through(MyFilter.class);
       filter("*.css").through(MyCssFilter.class);
       filter("*.jpg").through(new MyJpgFilter());
       // etc..

       serve("*.html").with(MyServlet.class);
       serve("/my/*").with(MyServlet.class);
       serve("*.jpg").with(new MyServlet());
       // etc..
      }
    }
 </pre><strike>
</strike><span style="background: #FFFF00">

</span> This will traverse down the list of rules in lexical order. For example, a <strike>url
 </strike><span style="background: #FFFF00">url</span> "{@<strike>code</strike><span style="background: #FFFF00">code
</span> /my/file.js}" (after it runs through the matching filters) will <strike>first
 </strike><span style="background: #FFFF00">first</span> be compared against <strike>the</strike><span style="background: #FFFF00">the
</span> servlet mapping:<strike>
 
</strike><span style="background: #FFFF00">

</span> <pre>
       serve("*.html").with(MyServlet.class);
 </pre><strike>
</strike><span style="background: #FFFF00">

</span> And failing that, it will descend to the next servlet mapping:

 <pre>
       serve("/my/*").with(MyServlet.class);
 </pre>

 Since this rule matches, Guice Servlet will dispatch to {@code MyServlet}. <strike>These
</strike><span style="background: #FFFF00">These</span> two <strike>mapping</strike><span style="background: #FFFF00">mapping
</span> rules can also be written in more compact form using varargs syntax:

 <pre>
       serve(<b>"*.html", "/my/*"</b>).with(MyServlet.class);
 </pre><strike>
 
</strike><span style="background: #FFFF00">

</span> This way you can map several URI patterns to the same servlet. A similar syntax <strike>is
 also</strike><span style="background: #FFFF00">is also
</span> available for filter mappings.

 <p><strike>
</strike><span style="background: #FFFF00">

</span> <h4>Regular Expressions</h4><strike>
</strike><span style="background: #FFFF00">

</span> You can also map servlets (or filters) to URIs using regular expressions:<strike>
</strike><span style="background: #FFFF00">

</span> <pre>
    <b>serveRegex("(.)*ajax(.)*").with(MyAjaxServlet.class)</b>
 </pre>

 This will map any URI containing the text "ajax" in it to {@code MyAjaxServlet}. Such as:<strike>
</strike><span style="background: #FFFF00">

</span> <ul>
 <li>http://www.google.com/ajax.<strike>html
</strike><span style="background: #FFFF00">html
</span> <li>http://www.google.com/content/ajax/<strike>index
</strike><span style="background: #FFFF00">index
</span> <li>http://www.google.com/it/is_totally_<strike>ajaxian
</strike><span style="background: #FFFF00">ajaxian
</span> </ul><strike>


</strike><span style="background: #FFFF00">

</span> <h3>Initialization Parameters</h3>

 Servlets (and filters) allow you to pass in init <strike>params
</strike><span style="background: #FFFF00">params</span> using the {@code <init-param>} tag <strike>in</strike><span style="background: #FFFF00">in
</span> web.xml. You can similarly pass in parameters <strike>to
</strike><span style="background: #FFFF00">to</span> Servlets and filters registered <strike>in</strike><span style="background: #FFFF00">in
</span> Guice-servlet using a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/java/util/Map.html"><TT>java.util.Map</TT></A> of <strike>parameter
</strike><span style="background: #FFFF00">parameter</span> name/value pairs. For example, <strike>to</strike><span style="background: #FFFF00">to
</span> initialize {@code MyServlet} with two <strike>parameters
</strike><span style="background: #FFFF00">parameters</span> ({@code name="Dhanji", site="google.com"}) <strike>you</strike><span style="background: #FFFF00">you
</span> could write:

 <pre>
  Map&lt;String, String&gt; params = new HashMap&lt;String, String&gt;();
  params.put("name", "Dhanji");
  params.put("site", "google.com");

  ...
      serve("/*").with(MyServlet.class, <b>params</b>)
 </pre>

 <p><strike>
</strike><span style="background: #FFFF00">

</span> <h3>Binding Keys</h3>

 You can also bind keys rather than classes. This lets you <strike>hide
</strike><span style="background: #FFFF00">hide</span> implementations <strike>with</strike><span style="background: #FFFF00">with
</span> package-local visbility and expose them <strike>using
</strike><span style="background: #FFFF00">using</span> only a Guice module and an annotation:

 <pre>
  ...
      filter("/*").through(<b>Key.get(Filter.class, Fave.class)</b>);
 </pre>

 Where {@code Filter.class} refers to the Servlet API interface and {@code Fave.class} is a
 custom binding annotation. Elsewhere (in one of your own modules) you can bind <strike>this
</strike><span style="background: #FFFF00">this</span> filter'<strike>s</strike><span style="background: #FFFF00">s
</span> implementation:

 <pre>
   bind(Filter.class)<b>.annotatedWith(Fave.class)</b>.to(MyFilterImpl.class);
 </pre>

 See <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/Binder.html"><TT>com.google.inject.Binder</TT></A> for more information on binding syntax.

 <p><strike>
</strike><span style="background: #FFFF00">

</span> <h3>Multiple Modules</h3>

 It is sometimes useful to capture servlet and filter mappings from multiple <strike>different
</strike><span style="background: #FFFF00">different</span> modules.<span style="background: #FFFF00">
</span> This is essential if you want to package and offer drop-in Guice plugins <strike>that
</strike><span style="background: #FFFF00">that</span> provide <strike>servlet</strike><span style="background: #FFFF00">servlet
</span> functionality.

 <p><strike>
 </strike>Guice Servlet allows you to register several instances of {@code ServletModule} to your
 injector. The order in which these modules are installed determines the dispatch <strike>order
 of</strike><span style="background: #FFFF00">order of
</span> filters and the precedence order of servlets. For example, if you had two servlet modules,
 {@code RpcModule} and {@code WebServiceModule} and they each contained a filter that <strike>mapped
</strike><span style="background: #FFFF00">mapped</span> <strike>to</strike><span style="background: #FFFF00">to
</span> the same URI pattern, {@code "/*"}:

 <p><strike>
 </strike>In {@code RpcModule}:<strike>
</strike><span style="background: #FFFF00">

</span> <pre>
     filter("/*").through(RpcFilter.class);
 </pre>

 In {@code WebServiceModule}:<strike>
</strike><span style="background: #FFFF00">

</span> <pre>
     filter("/*").through(WebServiceFilter.class);
 </pre>

 Then the order in which these filters are dispatched is determined by the order in <strike>which
 the</strike><span style="background: #FFFF00">which the
</span> modules are installed:

 <pre>
   <b>install(new WebServiceModule());</b>
   install(new RpcModule());
 </pre>

 In the case shown above {@code WebServiceFilter} will run first.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 2.0</blockquote>
<A NAME="com.google.inject.servlet.ServletModule.dmethod.getServletContext()"></A><a href="com.google.inject.servlet.ServletModule.html" class="hiddenlink">Class <b>ServletModule</b></a>, <a href="com.google.inject.servlet.ServletModule.html#com.google.inject.servlet.ServletModule.getServletContext_changed()" class="hiddenlink">ServletContext <b>getServletContext()</b></a><br><br><blockquote>This method only works if you are using the <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/lain.html"><TT>GuiceServletContextListener</TT></A> <strike>to
 create</strike><span style="background: #FFFF00">to create
</span> your injector. Otherwise, it returns null.<strike>
</strike><span style="background: #FFFF00">

</span> @return The current servlet context.
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.ServletModuleBinding!class"></A><a href="com.google.inject.servlet.ServletModuleBinding.html" class="hiddenlink">Class <b>ServletModuleBinding</b></a><br><br><blockquote>A binding created by <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ServletModuleBinding/ServletModule.html"><TT>ServletModule</TT></A>.<strike>
 
</strike><span style="background: #FFFF00">

</span> @author sameb@google.com (Sam Berlin)
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.ServletModuleTargetVisitor!class"></A><a href="com.google.inject.servlet.ServletModuleTargetVisitor.html" class="hiddenlink">Class <b>ServletModuleTargetVisitor</b></a><br><br><blockquote>A visitor for the servlet extension.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>If your <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ServletModuleTargetVisitor/BindingTargetVisitor.html"><TT>BindingTargetVisitor</TT></A> implements this interface, bindings created by using
 <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/servlet/ServletModuleTargetVisitor/ServletModule.html"><TT>ServletModule</TT></A> will be visited through this interface.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0
 @author sameb@google.com (Sam Berlin)</blockquote>
<A NAME="com.google.inject.servlet.ServletModuleTargetVisitor.dmethod.visit(InstanceFilterBinding)"></A><a href="com.google.inject.servlet.ServletModuleTargetVisitor.html" class="hiddenlink">Class <b>ServletModuleTargetVisitor</b></a>, <a href="com.google.inject.servlet.ServletModuleTargetVisitor.html#com.google.inject.servlet.ServletModuleTargetVisitor.visit_changed(com.google.inject.servlet.InstanceFilterBinding)" class="hiddenlink">V <b>visit(InstanceFilterBinding)</b></a><br><br><blockquote>Visits a filter binding created by <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletModule.html#filter"><TT>ServletModule.filter</TT></A> <strike>where
</strike><span style="background: #FFFF00">where</span> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/FilterKeyBindingBuilder.html#through"><TT>FilterKeyBindingBuilder.through</TT></A> is called with a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/Filter.html"><TT>Filter</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>If multiple patterns were specified, this will be called multiple times.</blockquote>
<A NAME="com.google.inject.servlet.ServletModuleTargetVisitor.dmethod.visit(InstanceServletBinding)"></A><a href="com.google.inject.servlet.ServletModuleTargetVisitor.html" class="hiddenlink">Class <b>ServletModuleTargetVisitor</b></a>, <a href="com.google.inject.servlet.ServletModuleTargetVisitor.html#com.google.inject.servlet.ServletModuleTargetVisitor.visit_changed(com.google.inject.servlet.InstanceServletBinding)" class="hiddenlink">V <b>visit(InstanceServletBinding)</b></a><br><br><blockquote>Visits a servlet binding created by <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletModule.html#serve"><TT>ServletModule.serve</TT></A> where <strike>
 </strike><A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletKeyBindingBuilder.html#with"><TT>ServletKeyBindingBuilder.with</TT></A>, is called with an <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/HttpServlet.html"><TT>HttpServlet</TT></A>.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>If multiple patterns were specified, this will be called multiple times.</blockquote>
<A NAME="com.google.inject.servlet.ServletModuleTargetVisitor.dmethod.visit(LinkedFilterBinding)"></A><a href="com.google.inject.servlet.ServletModuleTargetVisitor.html" class="hiddenlink">Class <b>ServletModuleTargetVisitor</b></a>, <a href="com.google.inject.servlet.ServletModuleTargetVisitor.html#com.google.inject.servlet.ServletModuleTargetVisitor.visit_changed(com.google.inject.servlet.LinkedFilterBinding)" class="hiddenlink">V <b>visit(LinkedFilterBinding)</b></a><br><br><blockquote>Visits a filter binding created by <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletModule.html#filter"><TT>ServletModule.filter</TT></A>, <strike>where
</strike><span style="background: #FFFF00">where</span> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/FilterKeyBindingBuilder.html#through"><TT>FilterKeyBindingBuilder.through</TT></A> is called with a Class or Key.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>If multiple patterns were specified, this will be called multiple times.</blockquote>
<A NAME="com.google.inject.servlet.ServletModuleTargetVisitor.dmethod.visit(LinkedServletBinding)"></A><a href="com.google.inject.servlet.ServletModuleTargetVisitor.html" class="hiddenlink">Class <b>ServletModuleTargetVisitor</b></a>, <a href="com.google.inject.servlet.ServletModuleTargetVisitor.html#com.google.inject.servlet.ServletModuleTargetVisitor.visit_changed(com.google.inject.servlet.LinkedServletBinding)" class="hiddenlink">V <b>visit(LinkedServletBinding)</b></a><br><br><blockquote>Visits a servlet binding created by <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletModule.html#serve"><TT>ServletModule.serve</TT></A> <strike>where
</strike><span style="background: #FFFF00">where</span> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ServletKeyBindingBuilder.html#with"><TT>ServletKeyBindingBuilder.with</TT></A>, is called with a Class or Key.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>If multiple patterns were specified, this will be called multiple times.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.continueRequest(Callable&lt;T&gt;, Map&lt;Key&lt;?&gt;, Object&gt;)"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.continueRequest_changed(java.util.concurrent.Callable<T>, java.util.Map<com.google.inject.Key<?>, java.lang.Object>)" class="hiddenlink">Callable&lt;T&gt; <b>continueRequest(Callable&lt;T&gt;, Map&lt;Key&lt;?&gt;, Object&gt;)</b></a><br><br><blockquote>Wraps the given callable in a contextual callable that "continues" <strike>the
</strike><span style="background: #FFFF00">the</span> HTTP request in <strike>another</strike><span style="background: #FFFF00">another
</span> thread. This acts as a way of <strike>transporting
</strike><span style="background: #FFFF00">transporting</span> request context data from the request <strike>processing</strike><span style="background: #FFFF00">processing
</span> thread to to <strike>worker
</strike><span style="background: #FFFF00">worker</span> threads.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>There are some limitations:<strike>
</strike><span style="background: #FFFF00">

</span> <ul>
 <strike>  </strike><li>Derived objects (i.e. anything marked @RequestScoped will not <strike>be
     </strike><span style="background: #FFFF00">be</span> transported.
 <strike>  </strike><li>State changes to the HttpServletRequest after this method is <strike>called
     </strike><span style="background: #FFFF00">called</span> will not be seen in <strike>the</strike><span style="background: #FFFF00">the
  </span> <span style="background: #FFFF00">  </span>continued thread.
 <strike>  </strike><li>Only the HttpServletRequest, ServletContext and request <strike>parameter
  </strike><span style="background: #FFFF00">parameter</span> <strike>   </strike>map are available in <strike>the</strike><span style="background: #FFFF00">the
 </span> <span style="background: #FFFF00">   </span>continued thread. The response and <strike>session
  </strike><span style="background: #FFFF00">session</span> <strike>   </strike>are not available.
 </ul>

 <p>The returned callable will throw a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ScopingException.html"><TT>ScopingException</TT></A> when <strike>called
</strike><span style="background: #FFFF00">called</span> if the HTTP <strike>request</strike><span style="background: #FFFF00">request
</span> scope is still active on the current thread.

 @param callable code to be executed in another thread, which depends <strike>on
    </strike><span style="background: #FFFF00">on</span> the request scope.
 @param seedMap the initial set of scoped instances for Guice to seed <strike>the
    </strike><span style="background: #FFFF00">the</span> request scope with. <span style="background: #FFFF00">To
 </span> <strike>To</strike> <span style="background: #FFFF00">  </span>seed a key with null, use {@code null} <strike>as
    </strike><span style="background: #FFFF00">as</span> the value.
 @return a callable that will invoke the given callable, making the <strike>request
</strike><span style="background: #FFFF00">request</span> <span style="background: #FFFF00">context</span> <span style="background: #FFFF00">available</span> <span style="background: #FFFF00">to
</span>  <strike>context</strike> <strike>available</strike> <strike>to</strike> it.
 @throws OutOfScopeException if this method is called from a non-<strike>request
    </strike><span style="background: #FFFF00">request</span> thread, or if <strike>the</strike><span style="background: #FFFF00">the
 </span> <span style="background: #FFFF00">   </span>request has completed.
 <strike>
 </strike>@since 3.0
 @deprecated You probably want to use {@code transferRequest} instead</blockquote>
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.isRequestScoped(Binding&lt;?&gt;)"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.isRequestScoped_changed(com.google.inject.Binding<?>)" class="hiddenlink">boolean <b>isRequestScoped(Binding&lt;?&gt;)</b></a><br><br><blockquote>Returns true if {@code binding} is request-scoped. If the binding is <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/com/google/inject/spi/LinkedKeyBinding.html"><TT>linked key binding</TT></A> <strike>and
</strike><span style="background: #FFFF00">and</span> belongs to an injector (i. e. <strike>it</strike><span style="background: #FFFF00">it
</span> was retrieved <strike>via
</strike><span style="background: #FFFF00">via</span> <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/Injector.html#getBinding"><TT>Injector.getBinding()</TT></A>), then this method will
 also return true if the target binding is request-scoped.

 @since 4.0</blockquote>
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.scopeRequest(Callable&lt;T&gt;, Map&lt;Key&lt;?&gt;, Object&gt;)"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.scopeRequest_changed(java.util.concurrent.Callable<T>, java.util.Map<com.google.inject.Key<?>, java.lang.Object>)" class="hiddenlink">Callable&lt;T&gt; <b>scopeRequest(Callable&lt;T&gt;, Map&lt;Key&lt;?&gt;, Object&gt;)</b></a><br><br><blockquote>Scopes the given callable inside a request scope. This is not the <strike>same
</strike><span style="background: #FFFF00">same</span> as the HTTP <strike>request</strike><span style="background: #FFFF00">request
</span> scope, but is used if no HTTP request scope is <strike>in
</strike><span style="background: #FFFF00">in</span> progress. In this way, keys can be <strike>scoped</strike><span style="background: #FFFF00">scoped
</span> as @RequestScoped and <strike>exist
</strike><span style="background: #FFFF00">exist</span> in non-HTTP requests (for example: RPC requests) as well as in HTTP
 request threads.

 <p>The returned callable will throw a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ScopingException.html"><TT>ScopingException</TT></A> when <strike>called
</strike><span style="background: #FFFF00">called</span> if there is <strike>a</strike><span style="background: #FFFF00">a
</span> request scope already active on the current thread.

 @param callable code to be executed which depends on the request scope.<strike>
</strike> <span style="background: #FFFF00">Typically</span> <span style="background: #FFFF00">in</span> <span style="background: #FFFF00">another
</span>  <strike>Typically</strike> <strike>in</strike> <strike>another</strike> thread, but not necessarily so.
 @param seedMap the initial set of scoped instances for Guice to seed <strike>the
    </strike><span style="background: #FFFF00">the</span> request scope with. <span style="background: #FFFF00">To
</span> <strike>To</strike> <span style="background: #FFFF00">   </span>seed a key with null, use {@code null} <strike>as
    </strike><span style="background: #FFFF00">as</span> the value.
 @return a callable that when called will run inside the a request <strike>scope
</strike><span style="background: #FFFF00">scope</span> <span style="background: #FFFF00">that</span> <span style="background: #FFFF00">exposes</span> <span style="background: #FFFF00">the
</span>  <strike>that</strike> <strike>exposes</strike> <strike>the</strike> instances in the {@code seedMap} as scoped keys.
 @since 3.0</blockquote>
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.scopeRequest(Map&lt;Key&lt;?&gt;, Object&gt;)"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.scopeRequest_changed(java.util.Map<com.google.inject.Key<?>, java.lang.Object>)" class="hiddenlink">RequestScoper <b>scopeRequest(Map&lt;Key&lt;?&gt;, Object&gt;)</b></a><br><br><blockquote>Returns an object that will apply request scope to a block of code. This <strike>is
</strike><span style="background: #FFFF00">is</span> not the same as <strike>the</strike><span style="background: #FFFF00">the
</span> HTTP request scope, but is used if no HTTP <strike>request
</strike><span style="background: #FFFF00">request</span> scope is in progress. In this way, keys <strike>can</strike><span style="background: #FFFF00">can
</span> be scoped as @RequestScoped <strike>and
</strike><span style="background: #FFFF00">and</span> exist in non-HTTP requests (for example: RPC requests) as <strike>well</strike><span style="background: #FFFF00">well
</span> as in <strike>HTTP
</strike><span style="background: #FFFF00">HTTP</span> request threads.

 <p>The returned object will throw a <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/ScopingException.html"><TT>ScopingException</TT></A> when <strike>opened
</strike><span style="background: #FFFF00">opened</span> if there is a <strike>request</strike><span style="background: #FFFF00">request
</span> scope already active on the current thread.

 @param seedMap the initial set of scoped instances for Guice to seed <strike>the
    </strike><span style="background: #FFFF00">the</span> request scope with. <span style="background: #FFFF00">To
   </span> <strike>To</strike> seed a key with null, use {@code null} <strike>as
    </strike><span style="background: #FFFF00">as</span> the value.
 @return an object that when opened will initiate the request scope
 @since 4.1</blockquote>
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.transferRequest()"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.transferRequest_changed()" class="hiddenlink">RequestScoper <b>transferRequest()</b></a><br><br><blockquote>Returns an object that "transfers" the request to another thread. This <strike>acts
</strike><span style="background: #FFFF00">acts</span> as a way <strike>of</strike><span style="background: #FFFF00">of
</span> transporting request context data from the current thread to <strike>a
</strike><span style="background: #FFFF00">a</span> future thread. The <strike>transferred</strike><span style="background: #FFFF00">transferred
</span> scope is the one active for the thread <strike>that
</strike><span style="background: #FFFF00">that</span> calls this method. A later call to {@code open()}<span style="background: #FFFF00">
</span> activates the <strike>transferred
</strike><span style="background: #FFFF00">transferred</span> the scope, including propagating any objects scoped at that time.

 <p>As opposed to <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/.html#continueRequest"><TT>.continueRequest</TT></A>, this method propagates <strike>all
</strike><span style="background: #FFFF00">all</span> existing scoped objects.<span style="background: #FFFF00">
</span> The primary use case is in server <strike>implementations
</strike><span style="background: #FFFF00">implementations</span> where you can detach the request <strike>processing</strike><span style="background: #FFFF00">processing
</span> thread while waiting for data,<strike>
</strike> and reattach to a different thread to finish processing at <strike>a</strike><span style="background: #FFFF00">a
</span> later time.

 <p>Because request-scoped objects are not typically thread-safe, it <strike>is
</strike><span style="background: #FFFF00">is</span> important to <strike>avoid</strike><span style="background: #FFFF00">avoid
</span> applying the same request scope concurrently. <strike>The
</strike><span style="background: #FFFF00">The</span> returned Scoper will block on open until <strike>the</strike><span style="background: #FFFF00">the
</span> current thread has <strike>released
</strike><span style="background: #FFFF00">released</span> the request scope.

 @return an object that when opened will initiate the request scope
 @throws OutOfScopeException if this method is called from a non-<strike>request
    </strike><span style="background: #FFFF00">request</span> thread, or if <strike>the</strike><span style="background: #FFFF00">the
    </span> request has completed.
 @since 4.1</blockquote>
<A NAME="com.google.inject.servlet.ServletScopes.dmethod.transferRequest(Callable&lt;T&gt;)"></A><a href="com.google.inject.servlet.ServletScopes.html" class="hiddenlink">Class <b>ServletScopes</b></a>, <a href="com.google.inject.servlet.ServletScopes.html#com.google.inject.servlet.ServletScopes.transferRequest_changed(java.util.concurrent.Callable<T>)" class="hiddenlink">Callable&lt;T&gt; <b>transferRequest(Callable&lt;T&gt;)</b></a><br><br><blockquote>Wraps the given callable in a contextual callable that "transfers" <strike>the
</strike><span style="background: #FFFF00">the</span> request to <strike>another</strike><span style="background: #FFFF00">another
</span> thread. This acts as a way of <strike>transporting
</strike><span style="background: #FFFF00">transporting</span> request context data from the current thread to <strike>a</strike><span style="background: #FFFF00">a
</span> future thread.

 <p>As opposed to <A HREF="http://google.github.io/guice/api-docs/latest/javadoc/.html#continueRequest"><TT>.continueRequest</TT></A>, this method propagates <strike>all
</strike><span style="background: #FFFF00">all</span> existing scoped objects.<span style="background: #FFFF00">
</span> The primary use case is in server <strike>implementations
</strike><span style="background: #FFFF00">implementations</span> where you can detach the request <strike>processing</strike><span style="background: #FFFF00">processing
</span> thread while waiting for data,<strike>
</strike> and reattach to a different thread to finish processing at <strike>a</strike><span style="background: #FFFF00">a
</span> later time.

 <p>Because request-scoped objects are not typically thread-safe, <strike>the
</strike><span style="background: #FFFF00">the</span> callable returned by <strike>this</strike><span style="background: #FFFF00">this
</span> method must not be run on a different <strike>thread
</strike><span style="background: #FFFF00">thread</span> until the current request scope has terminated.<span style="background: #FFFF00">
</span> The returned callable <strike>will
</strike><span style="background: #FFFF00">will</span> block until the current thread has released the request scope.

 @param callable code to be executed in another thread, which depends <strike>on
    </strike><span style="background: #FFFF00">on</span> the request scope.
 @return a callable that will invoke the given callable, making the <strike>request
</strike><span style="background: #FFFF00">request</span> <span style="background: #FFFF00">context</span> <span style="background: #FFFF00">available</span> <span style="background: #FFFF00">to
</span>  <strike>context</strike> <strike>available</strike> <strike>to</strike> it.
 @throws OutOfScopeException if this method is called from a non-<strike>request
    </strike><span style="background: #FFFF00">request</span> thread, or if <strike>the</strike><span style="background: #FFFF00">the
    </span> request has completed.
 @since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.servlet.UriPatternType!class"></A><a href="com.google.inject.servlet.UriPatternType.html" class="hiddenlink">Class <b>UriPatternType</b></a><br><br><blockquote>An enumeration of the available URI-pattern matching <strike>styles
</strike><span style="background: #FFFF00">styles

</span> <strike>
 </strike>@since 3.0</blockquote>
<hr align="left" width="100%">

</BODY>
</HTML>
