<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<HEAD>
<meta name="generator" content="JDiff v1.1.1">
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<meta name="description" content="JDiff is a Javadoc doclet which generates an HTML report of all the packages, classes, constructors, methods, and fields which have been removed, added or changed in any way, including their documentation, when two APIs are compared.">
<meta name="keywords" content="diff, jdiff, javadiff, java diff, java difference, API difference, difference between two APIs, API diff, Javadoc, doclet">
<LINK REL="stylesheet" TYPE="text/css" HREF="../stylesheet-jdiff.css" TITLE="Style">
<TITLE>
com.google.inject Documentation Differences
</TITLE>
</HEAD>
<BODY>
<!-- Start of nav bar -->
<TABLE summary="Navigation bar" BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
  <TABLE summary="Navigation bar" BORDER="0" CELLPADDING="0" CELLSPACING="3">
    <TR ALIGN="center" VALIGN="top">
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/package-summary.html" target="_top"><FONT CLASS="NavBarFont1"><B><tt>4.2</tt></B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="changes-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
      <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="docdiffs_index.html"><FONT CLASS="NavBarFont1"><B>Text Changes</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_statistics.html"><FONT CLASS="NavBarFont1"><B>Statistics</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_help.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
    </TR>
  </TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM><b>Generated by<br><a href="http://www.jdiff.org" class="staysblack" target="_top">JDiff</a></b></EM></TD>
</TR>
<TR>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><FONT SIZE="-2">
  <B>PREV PACKAGE</B>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.assistedinject.html"><B>NEXT PACKAGE</B></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <A HREF="../changes.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2">&nbsp;</TD>
</TR>
</TABLE>
<HR>
<!-- End of nav bar -->
<h2>
com.google.inject Documentation Differences
</h2>

<blockquote>
This file contains all the changes in documentation in the package <code>com.google.inject</code> as colored differences.
Deletions are shown <strike>like this</strike>, and
additions are shown <span style="background: #FFFF00">like this</span>.
</blockquote>
<blockquote>
If no deletions or additions are shown in an entry, the HTML tags will be what has changed. The <i>new</i> HTML tags are shown in the differences. 
If no documentation existed, and then some was added in a later version, this change is noted in the appropriate class pages of differences, but the change is not shown on this page. Only changes in existing text are shown here. 
Similarly, documentation which was inherited from another class or interface is not shown here.
</blockquote>
<blockquote>
 Note that an HTML error in the new documentation may cause the display of other documentation changes to be presented incorrectly. For instance, failure to close a &lt;code&gt; tag will cause all subsequent paragraphs to be displayed differently.
</blockquote>
<hr>

<A NAME="com.google.inject.AbstractModule!class"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a><br><br><blockquote>A support class for <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/AbstractModule/Module.html"><TT>Module</TT></A>s which reduces repetition and results <strike>in
</strike><span style="background: #FFFF00">in</span> a more <strike>readable</strike><span style="background: #FFFF00">readable
</span> configuration. Simply extend this class, implement <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/AbstractModule/.html#configure()"><TT>.configure()</TT></A>, and call the <strike>inherited</strike><span style="background: #FFFF00">inherited
</span> methods which mirror those found <strike>in
</strike><span style="background: #FFFF00">in</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/AbstractModule/Binder.html"><TT>Binder</TT></A>. For example:

 <pre>
 public class MyModule extends AbstractModule {
   protected void configure() {
     bind(Service.class).to(ServiceImpl.class).in(Singleton.class);
     bind(CreditCardPaymentService.class);
     bind(PaymentService.class).to(CreditCardPaymentService.class);
     bindConstant().annotatedWith(Names.named("port")).to(8080);
   }
 }
 </pre>

 @author crazybob@google.com (Bob Lee)</blockquote>
<A NAME="com.google.inject.AbstractModule.dmethod.bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a>, <a href="com.google.inject.AbstractModule.html#com.google.inject.AbstractModule.bindInterceptor_changed(com.google.inject.matcher.Matcher<? super java.lang.Class<?>>, com.google.inject.matcher.Matcher<? super java.lang.reflect.Method>, org.aopalliance.intercept.MethodInterceptor[])" class="hiddenlink">void <b>bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])</b></a><br><br><blockquote>@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,
  <span style="background: #FFFF00">   </span>com.google.inject.matcher.Matcher,<strike>
 </strike> org.aopalliance.intercept.MethodInterceptor[])</blockquote>
<A NAME="com.google.inject.AbstractModule.dmethod.bindListener(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeListener)"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a>, <a href="com.google.inject.AbstractModule.html#com.google.inject.AbstractModule.bindListener_changed(com.google.inject.matcher.Matcher<? super com.google.inject.TypeLiteral<?>>, com.google.inject.spi.TypeListener)" class="hiddenlink">void <b>bindListener(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeListener)</b></a><br><br><blockquote>@see Binder#bindListener(com.google.inject.matcher.Matcher,<strike>
 </strike> com.google.inject.spi.TypeListener)
 @since 2.0</blockquote>
<A NAME="com.google.inject.AbstractModule.dmethod.currentStage()"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a>, <a href="com.google.inject.AbstractModule.html#com.google.inject.AbstractModule.currentStage_changed()" class="hiddenlink">Stage <b>currentStage()</b></a><br><br><blockquote>@see Binder#currentStage()<strike> </strike>
 @since 2.0</blockquote>
<A NAME="com.google.inject.AbstractModule.dmethod.requireBinding(Class&lt;?&gt;)"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a>, <a href="com.google.inject.AbstractModule.html#com.google.inject.AbstractModule.requireBinding_changed(java.lang.Class<?>)" class="hiddenlink">void <b>requireBinding(Class&lt;?&gt;)</b></a><br><br><blockquote>Adds a dependency from this module to {@code type}. When the injector <strike>is
</strike><span style="background: #FFFF00">is</span> created, Guice <strike>will</strike><span style="background: #FFFF00">will
</span> report an error if {@code type} cannot be injected.<strike>
</strike> Note that this requirement may be <strike>satisfied</strike><span style="background: #FFFF00">satisfied
</span> by implicit binding, such <strike>as
</strike><span style="background: #FFFF00">as</span> a public no-arguments constructor.

 @since 2.0</blockquote>
<A NAME="com.google.inject.AbstractModule.dmethod.requireBinding(Key&lt;?&gt;)"></A><a href="com.google.inject.AbstractModule.html" class="hiddenlink">Class <b>AbstractModule</b></a>, <a href="com.google.inject.AbstractModule.html#com.google.inject.AbstractModule.requireBinding_changed(com.google.inject.Key<?>)" class="hiddenlink">void <b>requireBinding(Key&lt;?&gt;)</b></a><br><br><blockquote>Adds a dependency from this module to {@code key}. When the injector <strike>is
</strike><span style="background: #FFFF00">is</span> created, Guice <strike>will</strike><span style="background: #FFFF00">will
</span> report an error if {@code key} cannot be injected.<strike>
</strike> Note that this requirement may be <strike>satisfied</strike><span style="background: #FFFF00">satisfied
</span> by implicit binding, such <strike>as
</strike><span style="background: #FFFF00">as</span> a public no-arguments constructor.

 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Binder!class"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a><br><br><blockquote>Collects configuration information (primarily <i>bindings</i>) which will <strike>be
</strike><span style="background: #FFFF00">be</span> used to create <strike>an</strike><span style="background: #FFFF00">an
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Injector.html"><TT>Injector</TT></A>. Guice provides this object to <strike>your
</strike><span style="background: #FFFF00">your</span> application's <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Module.html"><TT>Module</TT></A> implementors <strike>so</strike><span style="background: #FFFF00">so
</span> they may each <strike>contribute
</strike><span style="background: #FFFF00">contribute</span> their own bindings and other registrations.

 <h3>The Guice Binding EDSL</h3>

 Guice uses an <i>embedded domain-specific language</i>, or EDSL, to help <strike>you
</strike><span style="background: #FFFF00">you</span> create <strike>bindings</strike><span style="background: #FFFF00">bindings
</span> simply and readably. <strike> </strike>This approach is great for <strike>overall
</strike><span style="background: #FFFF00">overall</span> usability, but it does come with a <strike>small</strike><span style="background: #FFFF00">small
</span> cost: <b>it is difficult <strike>to
</strike><span style="background: #FFFF00">to</span> learn how to use the Binding EDSL by <strike>reading
</strike><span style="background: #FFFF00">reading</span> method-<strike>level</strike><span style="background: #FFFF00">level
</span> javadocs</b>. <strike> </strike>Instead, you should consult the series <strike>of
</strike><span style="background: #FFFF00">of</span> examples below. <strike> </strike>To save space, <strike>these</strike><span style="background: #FFFF00">these
</span> examples omit the <strike>opening
</strike><span style="background: #FFFF00">opening</span> {@code binder}, just as you will if your module <strike>extends
</strike><span style="background: #FFFF00">extends</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/AbstractModule.html"><TT>AbstractModule</TT></A>.

 <pre>
     bind(ServiceImpl.class);</pre>

 This statement does essentially nothing; it "binds the {@code ServiceImpl}<strike>
</strike> class to itself" <strike>and</strike><span style="background: #FFFF00">and
</span> does not change Guice's default behavior. <strike> </strike>You may <strike>still
</strike><span style="background: #FFFF00">still</span> want to use this if you prefer <strike>your</strike><span style="background: #FFFF00">your
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Module.html"><TT>Module</TT></A> class to serve as <strike>an
</strike><span style="background: #FFFF00">an</span> explicit <i>manifest</i> for the services it provides. <strike> </strike>Also,<span style="background: #FFFF00">
</span> in rare cases,<strike>
</strike> Guice may be unable to validate a binding at injector creation time unless <strike>it
 is</strike><span style="background: #FFFF00">it is
</span> given explicitly.

 <pre>
     bind(Service.class).to(ServiceImpl.class);</pre>

 Specifies that a request for a {@code Service} instance with no <strike>binding
</strike><span style="background: #FFFF00">binding</span> annotations should <strike>be</strike><span style="background: #FFFF00">be
</span> treated as if it were a request for <strike>a
</strike><span style="background: #FFFF00">a</span> {@code ServiceImpl} instance. This <i>overrides</i> <strike>the</strike><span style="background: #FFFF00">the
</span> function of <strike>any
</strike><span style="background: #FFFF00">any</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/ImplementedBy.html"><TT>@ImplementedBy</TT></A> or <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/ProvidedBy.html"><TT>@ProvidedBy</TT></A>
 annotations found on {@code Service}, since Guice will have <strike>already
</strike><span style="background: #FFFF00">already</span> "moved on" to {@<strike>code</strike><span style="background: #FFFF00">code
</span> ServiceImpl} before it reaches the point when it <strike>starts
</strike><span style="background: #FFFF00">starts</span> looking for these annotations.

 <pre>
     bind(Service.class).toProvider(ServiceProvider.class);</pre>

 In this example, {@code ServiceProvider} must extend or <strike>implement
</strike><span style="background: #FFFF00">implement</span> {@code Provider<Service>}. <strike>This</strike><span style="background: #FFFF00">This
</span> binding specifies that Guice should <strike>resolve
</strike><span style="background: #FFFF00">resolve</span> an unannotated injection request for {@code Service}<span style="background: #FFFF00">
</span> by first resolving <strike>an
</strike><span style="background: #FFFF00">an</span> instance of {@code ServiceProvider} in the regular way, then <strike>calling
</strike><span style="background: #FFFF00">calling</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Provider.html#get"><TT>get()</TT></A> on the resulting Provider instance to obtain <strike>the
</strike><span style="background: #FFFF00">the</span> {@code Service} instance.

 <p>The <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Provider.html"><TT>Provider</TT></A> you use here does not have to be a "factory"; <strike>that
</strike><span style="background: #FFFF00">that</span> is, a provider <strike>which</strike><span style="background: #FFFF00">which
</span> always <i>creates</i> each instance it provides.<strike>
</strike> However, this is generally a good practice <strike>to</strike><span style="background: #FFFF00">to
</span> follow. <strike> </strike>You can then <strike>use
</strike><span style="background: #FFFF00">use</span> Guice's concept of <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Scope.html"><TT>scopes</TT></A> to guide when creation <strike>should</strike><span style="background: #FFFF00">should
</span> <strike>happen
</strike><span style="background: #FFFF00">happen</span> -- "letting Guice work for you".

 <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);</pre>

 Like the previous example, but only applies to injection requests that <strike>use
</strike><span style="background: #FFFF00">use</span> the binding <strike>annotation</strike><span style="background: #FFFF00">annotation
</span> {@code @Red}. <strike> </strike>If your module also includes <strike>bindings
</strike><span style="background: #FFFF00">bindings</span> for particular <i>values</i> of <strike>the</strike><span style="background: #FFFF00">the
</span> {@code @Red} annotation (see below),<strike>
</strike> then this binding will serve as a "catch-all" for any <strike>values</strike><span style="background: #FFFF00">values
</span> of {@code @Red}<strike>
</strike> that have no exact match in the bindings.<strike>
 
</strike><span style="background: #FFFF00">

</span> <pre>
     bind(ServiceImpl.class).in(Singleton.class);
     // or, alternatively
     bind(ServiceImpl.class).in(Scopes.SINGLETON);</pre>

 Either of these statements places the {@code ServiceImpl} class <strike>into
</strike><span style="background: #FFFF00">into</span> singleton scope. <strike> </strike>Guice <strike>will</strike><span style="background: #FFFF00">will
</span> create only one instance of {@code ServiceImpl}<strike>
</strike> and will reuse it for all injection requests <strike>of</strike><span style="background: #FFFF00">of
</span> this type. <strike> </strike>Note that it <strike>is
</strike><span style="background: #FFFF00">is</span> still possible to bind another instance of {@code ServiceImpl} if <strike>the</strike><span style="background: #FFFF00">the
</span> <strike>second
</strike><span style="background: #FFFF00">second</span> binding is qualified by an annotation as in the previous example. <strike> </strike>Guice <strike>is
</strike><span style="background: #FFFF00">is</span> not <strike>overly</strike><span style="background: #FFFF00">overly
</span> concerned with <i>preventing</i> you from creating <strike>multiple
</strike><span style="background: #FFFF00">multiple</span> instances of your "singletons", <strike>only</strike><span style="background: #FFFF00">only
</span> with <i>enabling</i> your application <strike>to
</strike><span style="background: #FFFF00">to</span> share only one instance if that's all you tell Guice <strike>you</strike><span style="background: #FFFF00">you
</span> need.

 <p><b>Note:</b> a scope specified in this way <i>overrides</i> any scope <strike>that
</strike><span style="background: #FFFF00">that</span> was specified <strike>with</strike><span style="background: #FFFF00">with
</span> an annotation on the {@code ServiceImpl} class.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>Besides <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Singleton.html"><TT>Singleton</TT></A>/<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Scopes.html#SINGLETON"><TT>Scopes.SINGLETON</TT></A>, there <strike>are
</strike><span style="background: #FFFF00">are</span> servlet-specific <strike>scopes</strike><span style="background: #FFFF00">scopes
</span> available <strike>in
</strike><span style="background: #FFFF00">in</span> {@code com.google.inject.servlet.ServletScopes}, and your Modules <strike>can
</strike><span style="background: #FFFF00">can</span> <strike>contribute</strike><span style="background: #FFFF00">contribute
</span> their own custom scopes for use here as well.

 <pre>
     bind(new TypeLiteral&lt;PaymentService&lt;CreditCard>>() {})
         .to(CreditCardPaymentService.class);</pre>

 This admittedly odd construct is the way to bind a parameterized type. <strike>It
</strike><span style="background: #FFFF00">It</span> tells Guice how <strike>to</strike><span style="background: #FFFF00">to
</span> honor an injection request for an element of <strike>type
</strike><span style="background: #FFFF00">type</span> {@code PaymentService<CreditCard>}. The class
 {@code CreditCardPaymentService} must implement <strike>the
</strike><span style="background: #FFFF00">the</span> {@code PaymentService<CreditCard>} interface.<strike> </strike><span style="background: #FFFF00">
</span> Guice cannot currently bind <strike>or
</strike><span style="background: #FFFF00">or</span> inject a generic type, such as {@code Set<E>}; all type <strike>parameters</strike><span style="background: #FFFF00">parameters
</span> must <strike>be
</strike><span style="background: #FFFF00">be</span> fully specified.

 <pre>
     bind(Service.class).toInstance(new ServiceImpl());
     // or, alternatively
     bind(Service.class).toInstance(SomeLegacyRegistry.getService());</pre>

 In this example, your module itself, <i>not Guice</i>, takes <strike>responsibility
</strike><span style="background: #FFFF00">responsibility</span> for obtaining <strike>a</strike><span style="background: #FFFF00">a
</span> {@code ServiceImpl} instance, then asks Guice to always <strike>use
</strike><span style="background: #FFFF00">use</span> this single instance to fulfill <strike>all</strike><span style="background: #FFFF00">all
</span> {@code Service} injection requests. <strike> When
</strike><span style="background: #FFFF00">When</span> the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Injector.html"><TT>Injector</TT></A> is created, it will <strike>automatically</strike><span style="background: #FFFF00">automatically
</span> perform <strike>field
</strike><span style="background: #FFFF00">field</span> and method injection for this instance, but any injectable constructor <strike>on
</strike><span style="background: #FFFF00">on</span> {@<strike>code</strike><span style="background: #FFFF00">code
</span> ServiceImpl} is simply ignored. <strike> </strike>Note that using this approach <strike>results
</strike><span style="background: #FFFF00">results</span> in "eager loading" <strike>behavior</strike><span style="background: #FFFF00">behavior
</span> that you can't control.

 <pre>
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre>

 Sets up a constant binding. Constant injections must always be annotated.<strike>
</strike> When a <strike>constant</strike><span style="background: #FFFF00">constant
</span> binding's value is a string, it is eligile for conversion <strike>to
</strike><span style="background: #FFFF00">to</span> all primitive types, to <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Enum.html#valueOf(Class, String)"><TT>all enums</TT></A>, and <strike>to
</strike><span style="background: #FFFF00">to</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Class.html#forName"><TT>class literals</TT></A>. <strike>Conversions</strike><span style="background: #FFFF00">Conversions
</span> for other types can <strike>be
</strike><span style="background: #FFFF00">be</span> configured using <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#convertToTypes(Matcher, TypeConverter)"><TT> convertToTypes()</TT></A>.

 <pre>
   {@literal @}Color("red") Color red; // A member variable (field)
    . . .
     red = MyModule.class.getDeclaredField("red").getAnnotation(Color.class);
     bind(Service.class).annotatedWith(red).to(RedService.class);</pre>

 If your binding annotation has parameters you can apply different bindings <strike>to
</strike><span style="background: #FFFF00">to</span> different <strike>specific</strike><span style="background: #FFFF00">specific
</span> values of your annotation. <strike> </strike>Getting your hands on <strike>the
</strike><span style="background: #FFFF00">the</span> right instance of the annotation is a bit <strike>of</strike><span style="background: #FFFF00">of
</span> a pain -- one approach, <strike>shown
</strike><span style="background: #FFFF00">shown</span> above, is to apply a prototype annotation to a field in your <strike>module</strike><span style="background: #FFFF00">module
</span> class, <strike>so
</strike><span style="background: #FFFF00">so</span> that you can read this annotation instance and give it to Guice.

 <pre>
     bind(Service.class)
         .annotatedWith(Names.named("blue"))
         .to(BlueService.class);</pre>

 Differentiating by names is a common enough use case that we provided <strike>a
</strike><span style="background: #FFFF00">a</span> standard annotation,<span style="background: #FFFF00">
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/com/google/inject/name/Named.html"><TT>@Named</TT></A>. <strike> </strike>Because <strike>of
</strike><span style="background: #FFFF00">of</span> Guice's library support, binding by <strike>name</strike><span style="background: #FFFF00">name
</span> is quite easier than in <strike>the
</strike><span style="background: #FFFF00">the</span> arbitrary binding annotation case we just saw. <strike> </strike>However, remember <strike>that these
</strike><span style="background: #FFFF00">that
 these</span> names will live in a single flat namespace with all the other names used <strike>in
</strike><span style="background: #FFFF00">in</span> <strike>your</strike><span style="background: #FFFF00">your
</span> application.

 <pre>
     Constructor<T> loneCtor = getLoneCtorFromServiceImplViaReflection();
     bind(ServiceImpl.class)
         .toConstructor(loneCtor);</pre>

 In this example, we directly tell Guice which constructor to use in a <strike>concrete
</strike><span style="background: #FFFF00">concrete</span> <strike>class</strike><span style="background: #FFFF00">class
</span> implementation. It means that we do not need to place {@literal @}<strike>Inject
</strike><span style="background: #FFFF00">Inject</span> on any of <strike>the</strike><span style="background: #FFFF00">the
</span> constructors and that Guice treats the provided constructor as <strike>though
</strike><span style="background: #FFFF00">though</span> it were annotated so. It <strike>is</strike><span style="background: #FFFF00">is
</span> useful for cases where you cannot modify <strike>existing
</strike><span style="background: #FFFF00">existing</span> classes and is a bit simpler than using <strike>a</strike><span style="background: #FFFF00">a
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/Provider.html"><TT>Provider</TT></A>.

 <p>The above list of examples is far from exhaustive. <strike> </strike>If you can think <strike>of
</strike><span style="background: #FFFF00">of</span> how the concepts of <strike>one</strike><span style="background: #FFFF00">one
</span> example might coexist with the concepts from another,<strike>
</strike> you can most likely weave the two together.<strike> </strike><span style="background: #FFFF00">
</span> If the two concepts make <strike>no
</strike><span style="background: #FFFF00">no</span> sense with each other, you most likely won't be able to do it. <strike> </strike>In <strike>a few
</strike><span style="background: #FFFF00">a
 few</span> cases Guice will let something bogus slip by, and will then inform you <strike>of
</strike><span style="background: #FFFF00">of</span> the problems <strike>at</strike><span style="background: #FFFF00">at
</span> runtime, as soon as you try to create your Injector.

 <p>The other methods of Binder such as <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#bindScope"><TT>.bindScope</TT></A>,<strike>
</strike> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#bindInterceptor"><TT>.bindInterceptor</TT></A>, <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#install"><TT>.install</TT></A>, <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#requestStaticInjection"><TT>.requestStaticInjection</TT></A>,<strike>
</strike> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#addError"><TT>.addError</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binder/.html#currentStage"><TT>.currentStage</TT></A> are <strike>not</strike><span style="background: #FFFF00">not
</span> part of the Binding EDSL;<strike>
</strike> you can learn how to use these in the usual way, from the method
 documentation.

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @author kevinb@google.com (Kevin Bourrillion)</blockquote>
<A NAME="com.google.inject.Binder.dmethod.addError(String, Object[])"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.addError_changed(java.lang.String, java.lang.Object[])" class="hiddenlink">void <b>addError(String, Object[])</b></a><br><br><blockquote>Records an error message which will be presented to the user at a <strike>later
</strike><span style="background: #FFFF00">later</span> time. Unlike <strike>throwing</strike><span style="background: #FFFF00">throwing
</span> an exception, this enable us to <strike>continue
</strike><span style="background: #FFFF00">continue</span> configuring the Injector and discover more errors.<span style="background: #FFFF00">
</span> Uses <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/String.html#format(String, Object[])"><TT>String.format(String, Object[])</TT></A> to insert the arguments into <strike>the
</strike><span style="background: #FFFF00">the</span> message.</blockquote>
<A NAME="com.google.inject.Binder.dmethod.addError(Throwable)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.addError_changed(java.lang.Throwable)" class="hiddenlink">void <b>addError(Throwable)</b></a><br><br><blockquote>Records an exception, the full details of which will be logged, and <strike>the
</strike><span style="background: #FFFF00">the</span> message of which <strike>will</strike><span style="background: #FFFF00">will
</span> be presented to the user at a <strike>later
</strike><span style="background: #FFFF00">later</span> time. If your Module calls something that you worry <strike>may</strike><span style="background: #FFFF00">may
</span> fail, you <strike>should
</strike><span style="background: #FFFF00">should</span> catch the exception and pass it into this.</blockquote>
<A NAME="com.google.inject.Binder.dmethod.bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.bindInterceptor_changed(com.google.inject.matcher.Matcher<? super java.lang.Class<?>>, com.google.inject.matcher.Matcher<? super java.lang.reflect.Method>, org.aopalliance.intercept.MethodInterceptor[])" class="hiddenlink">void <b>bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])</b></a><br><br><blockquote>Binds method interceptor[s] to methods matched by class and method matchers. A method is
 eligible for interception if:

 <ul>
 <strike> </strike><li>Guice created the instance the method is <strike>on
 </strike><span style="background: #FFFF00">on
</span> <li>Neither the enclosing type nor the method is <strike>final
 </strike><span style="background: #FFFF00">final
</span> <li>And the method is package-private, protected, or <strike>public
</strike><span style="background: #FFFF00">public
</span> </ul>

 @param classMatcher matches classes the interceptor should apply to. <strike>For
 </strike><span style="background: #FFFF00">For</span> <strike>   </strike>example: {@<strike>code</strike><span style="background: #FFFF00">code
    </span> only(Runnable.class)}.
 @param methodMatcher matches methods the interceptor should apply to. <strike>For
</strike><span style="background: #FFFF00">For</span> <strike>    </strike>example: {@<strike>code</strike><span style="background: #FFFF00">code
   </span> <span style="background: #FFFF00"> </span>annotatedWith(Transactional.class)}.
 @param interceptors to bind. <strike> </strike>The interceptors are called in the order <strike>they
    </strike><span style="background: #FFFF00">they</span> are given.</blockquote>
<A NAME="com.google.inject.Binder.dmethod.bindListener(Matcher&lt;Binding&lt;?&gt;&gt;, ProvisionListener[])"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.bindListener_changed(com.google.inject.matcher.Matcher<? super com.google.inject.Binding<?>>, com.google.inject.spi.ProvisionListener[])" class="hiddenlink">void <b>bindListener(Matcher&lt;Binding&lt;?&gt;&gt;, ProvisionListener[])</b></a><br><br><blockquote>Registers listeners for provisioned objects. Guice will notify <strike>the
</strike><span style="background: #FFFF00">the</span> listeners just before <strike>and</strike><span style="background: #FFFF00">and
</span> after the object is provisioned. <strike>Provisioned
</strike><span style="background: #FFFF00">Provisioned</span> objects that are also injectable (<strike>everything</strike><span style="background: #FFFF00">everything
</span> except objects <strike>provided
</strike><span style="background: #FFFF00">provided</span> through Providers) can also be notified through <strike>TypeListeners</strike><span style="background: #FFFF00">TypeListeners
</span> registered <strike>in
</strike><span style="background: #FFFF00">in</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#bindListener"><TT>.bindListener</TT></A>.<strike>
 
</strike><span style="background: #FFFF00">

</span> @param bindingMatcher that matches bindings of provisioned objects the <strike>listener
    </strike><span style="background: #FFFF00">listener</span> <strike> </strike><span style="background: #FFFF00">should</span> <span style="background: #FFFF00">be
</span>   <strike>should</strike> <strike>be</strike> notified of
 @param listeners for provisioned objects matched by <strike>bindingMatcher 
</strike><span style="background: #FFFF00">bindingMatcher
</span> @since 4.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.convertToTypes(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeConverter)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.convertToTypes_changed(com.google.inject.matcher.Matcher<? super com.google.inject.TypeLiteral<?>>, com.google.inject.spi.TypeConverter)" class="hiddenlink">void <b>convertToTypes(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeConverter)</b></a><br><br><blockquote>Binds a type converter. The injector will use the given converter <strike>to
</strike><span style="background: #FFFF00">to</span> convert string <strike>constants</strike><span style="background: #FFFF00">constants
</span> to matching types as needed.

 @param typeMatcher matches types the converter can handle
 @param converter converts values
 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.disableCircularProxies()"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.disableCircularProxies_changed()" class="hiddenlink">void <b>disableCircularProxies()</b></a><br><br><blockquote>Prevents Guice from injecting dependencies that form a cycle, unless broken by <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Provider.html"><TT>Provider</TT></A>. By default, circular dependencies are not disabled.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If a parent injector disables circular dependencies, then all child injectors (and private
 modules within that injector) also disable circular dependencies. If a parent does not disable
 circular dependencies, a child injector or private module may optionally declare itself as
 disabling circular dependencies. If it does, the behavior is limited only to that child or any
 grandchildren. No siblings of the child will disable circular dependencies.

 @since 3.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.getProvider(Class&lt;T&gt;)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.getProvider_changed(java.lang.Class<T>)" class="hiddenlink">Provider&lt;T&gt; <b>getProvider(Class&lt;T&gt;)</b></a><br><br><blockquote>Returns the provider used to obtain instances for the given injection type.<strike>
</strike> The <strike>returned</strike><span style="background: #FFFF00">returned
</span> provider will not be valid until the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> has <strike>been
</strike><span style="background: #FFFF00">been</span> created. The provider will <strike>throw</strike><span style="background: #FFFF00">throw
</span> an {@code IllegalStateException} if <strike>you
</strike><span style="background: #FFFF00">you</span> try to use it beforehand.

 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.getProvider(Dependency&lt;T&gt;)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.getProvider_changed(com.google.inject.spi.Dependency<T>)" class="hiddenlink">Provider&lt;T&gt; <b>getProvider(Dependency&lt;T&gt;)</b></a><br><br><blockquote>Returns the provider used to obtain instances for the given injection key.<strike>
</strike> The <strike>returned</strike><span style="background: #FFFF00">returned
</span> provider will be attached to the injection point and <strike>will
</strike><span style="background: #FFFF00">will</span> follow the nullability specified <strike>in</strike><span style="background: #FFFF00">in
</span> the dependency.<strike>
</strike> Additionally, the returned provider will not be valid until the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> <strike>
 </strike>has been created. The provider will throw an {@code IllegalStateException} if <strike>you
 try</strike><span style="background: #FFFF00">you try
</span> to use it beforehand.

 @since 4.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.getProvider(Key&lt;T&gt;)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.getProvider_changed(com.google.inject.Key<T>)" class="hiddenlink">Provider&lt;T&gt; <b>getProvider(Key&lt;T&gt;)</b></a><br><br><blockquote>Returns the provider used to obtain instances for the given injection key.<strike>
</strike> The <strike>returned</strike><span style="background: #FFFF00">returned
</span> provider will not be valid until the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> has <strike>been
</strike><span style="background: #FFFF00">been</span> created. The provider will <strike>throw</strike><span style="background: #FFFF00">throw
</span> an {@code IllegalStateException} if <strike>you
</strike><span style="background: #FFFF00">you</span> try to use it beforehand.

 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.newPrivateBinder()"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.newPrivateBinder_changed()" class="hiddenlink">PrivateBinder <b>newPrivateBinder()</b></a><br><br><blockquote>Creates a new private child environment for bindings and other configuration. The returned
 binder can be used to add and configuration information in this environment. See <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/PrivateModule.html"><TT>PrivateModule</TT></A> for details.

 @return a binder that inherits configuration from this binder. Only exposed configuration on
     <strike> </strike>the returned binder will be visible to this binder.
 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requestInjection(Object)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requestInjection_changed(java.lang.Object)" class="hiddenlink">void <b>requestInjection(Object)</b></a><br><br><blockquote>Upon successful creation, the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> will inject instance <strike>fields
</strike><span style="background: #FFFF00">fields</span> and methods of <strike>the</strike><span style="background: #FFFF00">the
</span> given object.

 @param instance for which members will be injected
 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requestInjection(TypeLiteral&lt;T&gt;, T)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requestInjection_changed(com.google.inject.TypeLiteral<T>, T)" class="hiddenlink">void <b>requestInjection(TypeLiteral&lt;T&gt;, T)</b></a><br><br><blockquote>Upon successful creation, the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> will inject instance <strike>fields
</strike><span style="background: #FFFF00">fields</span> and methods of <strike>the</strike><span style="background: #FFFF00">the
</span> given object.

 @param type of instance
 @param instance for which members will be injected
 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requestStaticInjection(Class[])"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requestStaticInjection_changed(java.lang.Class[])" class="hiddenlink">void <b>requestStaticInjection(Class[])</b></a><br><br><blockquote>Upon successful creation, the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Injector.html"><TT>Injector</TT></A> will inject static <strike>fields
</strike><span style="background: #FFFF00">fields</span> and methods in <strike>the</strike><span style="background: #FFFF00">the
</span> given classes.

 @param types for which static members will be injected</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requireAtInjectOnConstructors()"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requireAtInjectOnConstructors_changed()" class="hiddenlink">void <b>requireAtInjectOnConstructors()</b></a><br><br><blockquote>Requires that a {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Inject.html"><TT>Inject</TT></A> annotation exists on a constructor in order for
 Guice to consider it an eligible injectable class. By default, Guice will inject classes that
 have a no-args constructor if no {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Inject.html"><TT>Inject</TT></A> annotation exists on any
 constructor.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If the class is bound using <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/LinkedBindingBuilder.html#toConstructor"><TT>LinkedBindingBuilder.toConstructor</TT></A>, Guice will <strike>still inject
</strike><span style="background: #FFFF00">still
 inject</span> that constructor regardless of annotations.

 @since 4.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requireExactBindingAnnotations()"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requireExactBindingAnnotations_changed()" class="hiddenlink">void <b>requireExactBindingAnnotations()</b></a><br><br><blockquote>Requires that Guice finds an exactly matching binding annotation. <strike> </strike>This disables <strike>the
</strike><span style="background: #FFFF00">the</span> error-<strike>prone</strike><span style="background: #FFFF00">prone
</span> feature in Guice where it can substitute a binding <strike>for
</strike><span style="background: #FFFF00">for</span> <code>{@literal @}Named Foo</code> <strike>when</strike><span style="background: #FFFF00">when
</span> attempting to <strike>inject
</strike><span style="background: #FFFF00">inject</span> <code>{@literal @}Named("foo") Foo</code>.

 @since 4.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.requireExplicitBindings()"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.requireExplicitBindings_changed()" class="hiddenlink">void <b>requireExplicitBindings()</b></a><br><br><blockquote>Instructs the Injector that bindings must be listed in a Module in order <strike>to
</strike><span style="background: #FFFF00">to</span> be injected.<span style="background: #FFFF00">
</span> Classes that are not explicitly bound in a module cannot <strike>be
</strike><span style="background: #FFFF00">be</span> injected. Bindings created <strike>through</strike><span style="background: #FFFF00">through
</span> a linked <strike>binding
</strike><span style="background: #FFFF00">binding</span> (<code>bind(Foo.class).to(FooImpl.class)</code>) are allowed, but <strike>the
</strike><span style="background: #FFFF00">the</span> <strike>implicit</strike><span style="background: #FFFF00">implicit
</span> binding (<code>FooImpl</code>) cannot be directly injected <strike>unless
</strike><span style="background: #FFFF00">unless</span> it is also explicitly bound (<span style="background: #FFFF00">
 </span><code>bind(FooImpl.class)</code>).<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>Tools can still retrieve bindings for implicit bindings (bindings <strike>created
</strike><span style="background: #FFFF00">created</span> through a <strike>linked</strike><span style="background: #FFFF00">linked
</span> binding) if explicit bindings are required, <strike>however
</strike><span style="background: #FFFF00">however</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Binding.html#getProvider"><TT>Binding.getProvider</TT></A> will fail.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>By default, explicit bindings are not required.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If a parent injector requires explicit bindings, then all child <strike>injectors
</strike><span style="background: #FFFF00">injectors</span> (and <strike>private</strike><span style="background: #FFFF00">private
</span> modules within that injector) also require explicit bindings.<strike>
</strike> If a parent does not <strike>require</strike><span style="background: #FFFF00">require
</span> explicit bindings, a child injector or <strike>private
</strike><span style="background: #FFFF00">private</span> module may optionally declare itself <strike>as</strike><span style="background: #FFFF00">as
</span> requiring explicit bindings. If <strike>it
</strike><span style="background: #FFFF00">it</span> does, the behavior is limited only to that child or <strike>any</strike><span style="background: #FFFF00">any
</span> grandchildren. <strike>No
</strike><span style="background: #FFFF00">No</span> siblings of the child will require explicit bindings.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>In the absence of an explicit binding for the target, linked bindings <strike>in
</strike><span style="background: #FFFF00">in</span> child <strike>injectors</strike><span style="background: #FFFF00">injectors
</span> create a binding for the target in the parent. Since <strike>this
</strike><span style="background: #FFFF00">this</span> behavior can be surprising, it <strike>causes</strike><span style="background: #FFFF00">causes
</span> an error instead if explicit <strike>bindings
</strike><span style="background: #FFFF00">bindings</span> are required. To avoid this error, add an <strike>explicit</strike><span style="background: #FFFF00">explicit
</span> binding for the target,<strike>
</strike> either in the child or the parent.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.skipSources(Class[])"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.skipSources_changed(java.lang.Class[])" class="hiddenlink">Binder <b>skipSources(Class[])</b></a><br><br><blockquote>Returns a binder that skips {@code classesToSkip} when identify <strike>the
</strike><span style="background: #FFFF00">the</span> calling code. The caller'<strike>s</strike><span style="background: #FFFF00">s
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/StackTraceElement.html"><TT>StackTraceElement</TT></A> is used to <strike>locate
</strike><span style="background: #FFFF00">locate</span> the source of configuration errors.

 @param classesToSkip library classes that create bindings on behalf <strike>of
     </strike><span style="background: #FFFF00">of</span> their clients.
 @return a binder that shares its configuration with this binder.
 @since 2.0</blockquote>
<A NAME="com.google.inject.Binder.dmethod.withSource(Object)"></A><a href="com.google.inject.Binder.html" class="hiddenlink">Class <b>Binder</b></a>, <a href="com.google.inject.Binder.html#com.google.inject.Binder.withSource_changed(java.lang.Object)" class="hiddenlink">Binder <b>withSource(Object)</b></a><br><br><blockquote>Returns a binder that uses {@code source} as the reference location <strike>for
</strike><span style="background: #FFFF00">for</span> configuration errors.<span style="background: #FFFF00">
</span> This is typically a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/StackTraceElement.html"><TT>StackTraceElement</TT></A><strike>
</strike> for {@code .java} source but it could any <strike>binding</strike><span style="background: #FFFF00">binding
</span> source, such as <strike>the
</strike><span style="background: #FFFF00">the</span> path to a {@code .properties} file.

 @param source any object representing the source location and has <strike>a
    </strike><span style="background: #FFFF00">a</span> concise <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Object.html#toString()"><TT>toString()</TT></A> value
 @return a binder that shares its configuration with this binder
 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Binding!class"></A><a href="com.google.inject.Binding.html" class="hiddenlink">Class <b>Binding</b></a><br><br><blockquote>A mapping from a key (type and optional annotation) to the strategy for getting instances of the
 type. This interface is part of the introspection API and is intended primarily for use by <strike>
 </strike>tools.

 <p>Bindings are created in several ways:<strike>
</strike><span style="background: #FFFF00">

</span> <ul>
 <strike>    </strike><li>Explicitly in a module, via {@code bind()} and {@code bindConstant()}<strike>
  </strike> <strike>  </strike><span style="background: #FFFF00">statements:
</span>    <strike>statements:
</strike> <pre>
     bind(Service.class).annotatedWith(Red.class).to(ServiceImpl.class);
     bindConstant().annotatedWith(ServerHost.class).to(args[0]);</pre><strike>
    </strike><span style="background: #FFFF00">

</span> <li>Implicitly by the Injector by following a type's <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binding/ImplementedBy.html"><TT><strike>         </strike>pointer</TT></A> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binding/ProvidedBy.html"><TT>annotations</TT></A> or by using its <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binding/Inject.html"><TT>annotated</TT></A> <strike>or
        </strike><span style="background: #FFFF00">or</span> default constructor.
 <strike>    </strike><li>By converting a bound instance to a different type.
 <strike>    </strike><li>For <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Binding/Provider.html"><TT>providers</TT></A>, by delegating to the binding for the provided type.
 </ul><strike>


</strike><span style="background: #FFFF00">

</span> <p>They exist on both modules and on injectors, and their behaviour is different for each:<strike>
</strike><span style="background: #FFFF00">

</span> <ul>
 <strike>    </strike><li><strong>Module bindings</strong> are incomplete and cannot be used to provide instances.<strike>
 </strike> <span style="background: #FFFF00">This
</span>     <strike>  This </strike>is because the applicable scopes and interceptors may not be known until an <strike>injector
    </strike><span style="background: #FFFF00">injector</span> <span style="background: #FFFF00">is
</span>    <strike>is</strike> created. From a tool's perspective, module bindings are like the injector's <strike>source
    </strike><span style="background: #FFFF00">source</span> <span style="background: #FFFF00">code.</span> <span style="background: #FFFF00">They
</span>   <strike>code.</strike> <strike>They</strike> can be inspected or rewritten, but this analysis must be done statically.
 <strike>    </strike><li><strong>Injector bindings</strong> are complete and valid and can be used to provide
     <strike>    </strike>instances. From a tools' perspective, injector bindings are like reflection for <strike>an
    </strike><span style="background: #FFFF00">an</span> <span style="background: #FFFF00">injector.
</span>    <strike>injector.</strike> They have full runtime information, including the complete graph of <strike>injections
   </strike><span style="background: #FFFF00">injections</span> <strike> </strike><span style="background: #FFFF00">necessary</span> <span style="background: #FFFF00">to
</span>   <strike>necessary</strike> <strike>to</strike> satisfy a binding.
 </ul>

 @param <T> the bound type. The injected is always assignable to this type.<strike>

</strike><span style="background: #FFFF00">
</span> @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)</blockquote>
<A NAME="com.google.inject.Binding.dmethod.getProvider()"></A><a href="com.google.inject.Binding.html" class="hiddenlink">Class <b>Binding</b></a>, <a href="com.google.inject.Binding.html#com.google.inject.Binding.getProvider_changed()" class="hiddenlink">Provider&lt;T&gt; <b>getProvider()</b></a><br><br><blockquote>Returns the scoped provider guice uses to fulfill requests for <strike>this
</strike><span style="background: #FFFF00">this</span> binding.

 @throws UnsupportedOperationException when invoked on a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Binding.html"><TT>Binding</TT></A><strike>
</strike> <strike>     </strike>created via <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/spi/Elements.html#getElements"><TT>com.google.inject.spi.Elements.getElements</TT></A>. <strike>This
     </strike><span style="background: #FFFF00">This</span> method is only supported on <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Binding.html"><TT>Binding</TT></A>s returned from an injector.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.BindingAnnotation!class"></A><a href="com.google.inject.BindingAnnotation.html" class="hiddenlink">Class <b>BindingAnnotation</b></a><br><br><blockquote>Annotates annotations which are used for binding. Only one such <strike>annotation
</strike><span style="background: #FFFF00">annotation</span> may apply to a <strike>single</strike><span style="background: #FFFF00">single
</span> injection point. You must also annotate <strike>binder
</strike><span style="background: #FFFF00">binder</span> annotations with {@code @Retention(RUNTIME)}. <strike>For</strike><span style="background: #FFFF00">For
</span> example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target({ FIELD, PARAMETER, METHOD })
   {@code @}BindingAnnotation
   public {@code @}interface Transactional {}
 </pre>

 @author crazybob@google.com (Bob Lee)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.ConfigurationException.dmethod.getPartialValue()"></A><a href="com.google.inject.ConfigurationException.html" class="hiddenlink">Class <b>ConfigurationException</b></a>, <a href="com.google.inject.ConfigurationException.html#com.google.inject.ConfigurationException.getPartialValue_changed()" class="hiddenlink">E <b>getPartialValue()</b></a><br><br><blockquote>Returns a value that was only partially computed due to this exception. The caller can <strike>use
 this</strike><span style="background: #FFFF00">use this
</span> while collecting additional configuration problems.

 @return the partial value, or {@code null} if none was set. The type of the partial value is
     <strike> </strike>specified by the throwing method.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Guice!class"></A><a href="com.google.inject.Guice.html" class="hiddenlink">Class <b>Guice</b></a><br><br><blockquote>The entry point to the Guice framework. Creates <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Guice/Injector.html"><TT>Injector</TT></A>s <strike>from
</strike><span style="background: #FFFF00">from</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Guice/Module.html"><TT>Module</TT></A>s.

 <p>Guice supports a model of development that draws clear boundaries <strike>between
</strike><span style="background: #FFFF00">between</span> APIs,<span style="background: #FFFF00">
</span> Implementations of these APIs, Modules which configure <strike>these
</strike><span style="background: #FFFF00">these</span> implementations, and <strike>finally</strike><span style="background: #FFFF00">finally
</span> Applications which consist of a collection <strike>of
</strike><span style="background: #FFFF00">of</span> Modules. It is the Application, which <strike>typically</strike><span style="background: #FFFF00">typically
</span> defines your {@code main()}<strike>
</strike> method, that bootstraps the Guice Injector using the {@code Guice}<span style="background: #FFFF00">
</span> class, <strike>as
</strike><span style="background: #FFFF00">as</span> in this example:<strike>
</strike><span style="background: #FFFF00">

</span> <pre>
     public class FooApplication {
       public static void main(String[] args) {
         Injector injector = Guice.createInjector(
             new ModuleA(),
             new ModuleB(),
             . . .
             new FooApplicationFlagsModule(args)
         );

         // Now just bootstrap the application and you're done
         FooStarter starter = injector.getInstance(FooStarter.class);
         starter.runApplication();
       }
     }
 </pre></blockquote>
<A NAME="com.google.inject.Guice.dmethod.createInjector(Iterable&lt;Module&gt;)"></A><a href="com.google.inject.Guice.html" class="hiddenlink">Class <b>Guice</b></a>, <a href="com.google.inject.Guice.html#com.google.inject.Guice.createInjector_changed(java.lang.Iterable<? extends com.google.inject.Module>)" class="hiddenlink">Injector <b>createInjector(Iterable&lt;Module&gt;)</b></a><br><br><blockquote>Creates an injector for the given set of modules. This is equivalent <strike>to
</strike><span style="background: #FFFF00">to</span> calling <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#createInjector(Stage, Iterable)"><TT>.createInjector(Stage, Iterable)</TT></A> with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during <strike>injector
    </strike><span style="background: #FFFF00">injector</span> creation</blockquote>
<A NAME="com.google.inject.Guice.dmethod.createInjector(Module[])"></A><a href="com.google.inject.Guice.html" class="hiddenlink">Class <b>Guice</b></a>, <a href="com.google.inject.Guice.html#com.google.inject.Guice.createInjector_changed(com.google.inject.Module[])" class="hiddenlink">Injector <b>createInjector(Module[])</b></a><br><br><blockquote>Creates an injector for the given set of modules. This is equivalent <strike>to
</strike><span style="background: #FFFF00">to</span> calling <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#createInjector(Stage, Module...)"><TT>.createInjector(Stage, Module...)</TT></A> with Stage.DEVELOPMENT.

 @throws CreationException if one or more errors occur during <strike>injector
    </strike><span style="background: #FFFF00">injector</span> construction</blockquote>
<A NAME="com.google.inject.Guice.dmethod.createInjector(Stage, Iterable&lt;Module&gt;)"></A><a href="com.google.inject.Guice.html" class="hiddenlink">Class <b>Guice</b></a>, <a href="com.google.inject.Guice.html#com.google.inject.Guice.createInjector_changed(com.google.inject.Stage, java.lang.Iterable<? extends com.google.inject.Module>)" class="hiddenlink">Injector <b>createInjector(Stage, Iterable&lt;Module&gt;)</b></a><br><br><blockquote>Creates an injector for the given set of modules, in a given <strike>development
</strike><span style="background: #FFFF00">development</span> stage.

 @throws CreationException if one or more errors occur during <strike>injector
    </strike><span style="background: #FFFF00">injector</span> construction</blockquote>
<A NAME="com.google.inject.Guice.dmethod.createInjector(Stage, Module[])"></A><a href="com.google.inject.Guice.html" class="hiddenlink">Class <b>Guice</b></a>, <a href="com.google.inject.Guice.html#com.google.inject.Guice.createInjector_changed(com.google.inject.Stage, com.google.inject.Module[])" class="hiddenlink">Injector <b>createInjector(Stage, Module[])</b></a><br><br><blockquote>Creates an injector for the given set of modules, in a given <strike>development
</strike><span style="background: #FFFF00">development</span> stage.

 @throws CreationException if one or more errors occur during <strike>injector
    </strike><span style="background: #FFFF00">injector</span> creation.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Inject!class"></A><a href="com.google.inject.Inject.html" class="hiddenlink">Class <b>Inject</b></a><br><br><blockquote>Annotates members of your implementation class (constructors, <strike>methods
</strike><span style="background: #FFFF00">methods</span> and fields) into which <strike>the</strike><span style="background: #FFFF00">the
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/Injector.html"><TT>Injector</TT></A> should inject values.<strike>
</strike> The Injector fulfills injection requests for:

 <ul>
 <li>Every instance it constructs. The class being constructed must <strike>have
</strike><span style="background: #FFFF00">have</span> exactly one of <strike>its</strike><span style="background: #FFFF00">its
    </span> constructors marked with {@code @Inject} or must have <strike>a
</strike><span style="background: #FFFF00">a</span> constructor taking no parameters. <strike>The</strike><span style="background: #FFFF00">The
  </span> <span style="background: #FFFF00">  </span>Injector then proceeds to <strike>perform
</strike><span style="background: #FFFF00">perform</span> field and method injections.
 <strike>
 </strike><li>Pre-constructed instances passed to <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/Injector.html#injectMembers"><TT>Injector.injectMembers</TT></A>,<strike>
</strike> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/com/google/inject/binder/LinkedBindingBuilder.html#toInstance(Object)"><TT>com.google.inject.binder.LinkedBindingBuilder.toInstance(Object)</TT></A> <strike>and
</strike><span style="background: #FFFF00">and</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/com/google/inject/binder/LinkedBindingBuilder.html#toProvider(javax.inject.Provider)"><TT>com.google.inject.binder.LinkedBindingBuilder.toProvider(javax.inject.Provider)</TT></A>.<strike>
</strike> In <strike>this</strike><span style="background: #FFFF00">this
    </span> case all constructors are, of course, ignored.<strike>

</strike><span style="background: #FFFF00">
</span> <li>Static fields and methods of classes which any <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/Module.html"><TT>Module</TT></A> <strike>has
</strike><span style="background: #FFFF00">has</span> specifically <strike>requested</strike><span style="background: #FFFF00">requested
  </span> <span style="background: #FFFF00">  </span>static injection for, <strike>using
</strike><span style="background: #FFFF00">using</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Inject/Binder.html#requestStaticInjection"><TT>Binder.requestStaticInjection</TT></A>.
 </ul>

 In all cases, a member can be injected regardless of its Java <strike>access
</strike><span style="background: #FFFF00">access</span> specifier (private, default,<span style="background: #FFFF00">
</span> protected, public).

 @author crazybob@google.com (Bob Lee)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Injector.dmethod.createChildInjector(Iterable&lt;Module&gt;)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.createChildInjector_changed(java.lang.Iterable<? extends com.google.inject.Module>)" class="hiddenlink">Injector <b>createChildInjector(Iterable&lt;Module&gt;)</b></a><br><br><blockquote>Returns a new injector that inherits all state from this injector. All bindings, scopes,
 interceptors and type converters are inherited -- they are visible to the child injector.
 Elements of the child injector are not visible to its parent.

 <p>Just-in-time bindings created for child injectors will be created in an ancestor injector
 whenever possible. This allows for scoped instances to be shared between injectors. Use
 explicit bindings to prevent bindings from being shared with the parent injector. <strike> </strike>Optional
 injections in just-in-time bindings (created in the parent injector) may be <strike>silently
</strike><span style="background: #FFFF00">silently</span> ignored <strike>if</strike><span style="background: #FFFF00">if
</span> the optional dependencies are from the child injector.

 <p>No key may be bound by both an injector and one of its ancestors. This includes just-in-time
 bindings. The lone exception is the key for {@code Injector.class}, which is bound by each
 injector to itself.

 @since 2.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getAllBindings()"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getAllBindings_changed()" class="hiddenlink">Map&lt;Key&lt;?&gt;, Binding&lt;?&gt;&gt; <b>getAllBindings()</b></a><br><br><blockquote>Returns a snapshot of this injector's bindings, <strong>both explicit and
 just-in-time</strong>. The returned map is immutable; it contains only the bindings that were
 present when {@code getAllBindings()} was invoked. <span style="background: #FFFF00">Just-in-time bindings are only present if
 they have been requested at least once. </span>Subsequent calls may return a map <strike>with
 additional</strike><span style="background: #FFFF00">with additional
</span> just-in-time bindings.

 <p>The returned map does not include bindings inherited from a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getParent()"><TT>parent
 injector</TT></A>, should one exist.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getBindings()"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getBindings_changed()" class="hiddenlink">Map&lt;Key&lt;?&gt;, Binding&lt;?&gt;&gt; <b>getBindings()</b></a><br><br><blockquote>Returns this injector's <strong>explicit</strong> bindings.

 <p>The returned map does not include bindings inherited from a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getParent()"><TT>parent
 injector</TT></A>, should one exist. The returned map is guaranteed to iterate (for example, <strike>with
 its</strike><span style="background: #FFFF00">with its
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html#entrySet()"><TT>Map.entrySet()</TT></A> iterator) in the order of insertion. In other words, the order <strike>in
</strike><span style="background: #FFFF00">in</span> <strike>which</strike><span style="background: #FFFF00">which
</span> bindings appear in user Modules.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getExistingBinding(Key&lt;T&gt;)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getExistingBinding_changed(com.google.inject.Key<T>)" class="hiddenlink">Binding&lt;T&gt; <b>getExistingBinding(Key&lt;T&gt;)</b></a><br><br><blockquote>Returns the binding if it already exists, or null if does not exist. <strike>Unlike
</strike><span style="background: #FFFF00">Unlike</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getBinding(Key)"><TT>.getBinding(Key)</TT></A>, this does not attempt to create just-in-time <strike>bindings
</strike><span style="background: #FFFF00">bindings</span> for keys that aren'<strike>t</strike><span style="background: #FFFF00">t
</span> bound.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p><strike> </strike>This method is part of the Guice SPI and is intended for use by tools and extensions.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getMembersInjector(Class&lt;T&gt;)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getMembersInjector_changed(java.lang.Class<T>)" class="hiddenlink">MembersInjector&lt;T&gt; <b>getMembersInjector(Class&lt;T&gt;)</b></a><br><br><blockquote>Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}. When feasible, use <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Binder.html#getMembersInjector(TypeLiteral)"><TT>Binder.getMembersInjector(TypeLiteral)</TT></A>
 instead to get increased up front error detection.

 @param type type to get members injector for
 @see Binder#getMembersInjector(Class) for an alternative that offers up front <strike>error
 </strike><span style="background: #FFFF00">error</span> detection
 @since 2.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getMembersInjector(TypeLiteral&lt;T&gt;)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getMembersInjector_changed(com.google.inject.TypeLiteral<T>)" class="hiddenlink">MembersInjector&lt;T&gt; <b>getMembersInjector(TypeLiteral&lt;T&gt;)</b></a><br><br><blockquote>Returns the members injector used to inject dependencies into methods and fields on instances
 of the given type {@code T}.

 @param typeLiteral type to get members injector for
 @see Binder#getMembersInjector(TypeLiteral) for an alternative that offers up front error
  <span style="background: #FFFF00">   </span>detection
 @since 2.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getProvider(Class&lt;T&gt;)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getProvider_changed(java.lang.Class<T>)" class="hiddenlink">Provider&lt;T&gt; <b>getProvider(Class&lt;T&gt;)</b></a><br><br><blockquote>Returns the provider used to obtain instances for the given type. When feasible, <strike>avoid
 using</strike><span style="background: #FFFF00">avoid using
</span> this method, in favor of having Guice inject your dependencies ahead of time.

 @throws ConfigurationException if this injector cannot find or create the provider.
 @see Binder#getProvider(Class) for an alternative that offers up front error detection</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getScopeBindings()"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getScopeBindings_changed()" class="hiddenlink">Map&lt;Class&lt;Annotation&gt;, Scope&gt; <b>getScopeBindings()</b></a><br><br><blockquote>Returns a map containing all scopes in the injector. The maps keys are scoping <strike>annotations
 like</strike><span style="background: #FFFF00">annotations like
</span> {@code Singleton.class}, and the values are scope instances, such as {@<strike>code
</strike><span style="background: #FFFF00">code</span> Scopes.SINGLETON}.<span style="background: #FFFF00">
</span> The returned map is immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.getTypeConverterBindings()"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.getTypeConverterBindings_changed()" class="hiddenlink">Set&lt;TypeConverterBinding&gt; <b>getTypeConverterBindings()</b></a><br><br><blockquote>Returns a set containing all type converter bindings in the injector. The returned set is
 immutable.

 <p>This method is part of the Guice SPI and is intended for use by tools and extensions.<strike>
 
</strike><span style="background: #FFFF00">

</span> @since 3.0</blockquote>
<A NAME="com.google.inject.Injector.dmethod.injectMembers(Object)"></A><a href="com.google.inject.Injector.html" class="hiddenlink">Class <b>Injector</b></a>, <a href="com.google.inject.Injector.html#com.google.inject.Injector.injectMembers_changed(java.lang.Object)" class="hiddenlink">void <b>injectMembers(Object)</b></a><br><br><blockquote>Injects dependencies into the fields and methods of {@code instance}. Ignores the presence or
 absence of an injectable constructor.

 <p>Whenever Guice creates an instance, it performs this injection automatically (after first
 performing constructor injection), so if you're able to let Guice create all your objects for
 you, you'll never need to use this method.

 @param instance to inject members <strike>on

</strike><span style="background: #FFFF00">on
</span> @see Binder#getMembersInjector(Class) for a preferred alternative that supports checks before
  <span style="background: #FFFF00">   </span>run time</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Key!class"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a><br><br><blockquote>Binding key consisting of an injection type and an optional annotation.<strike>
</strike> Matches the type <strike>and</strike><span style="background: #FFFF00">and
</span> annotation at a point of injection.

 <p>For example, {@code Key.get(Service.class, Transactional.class)} <strike>will
</strike><span style="background: #FFFF00">will</span> match:

 <pre>
   {@literal @}Inject
   public void setService({@literal @}Transactional Service service) {
     ...
   }
 </pre>

 <p>{@code Key} supports generic types via subclassing just like <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Key/TypeLiteral.html"><TT>TypeLiteral</TT></A>.

 <p>Keys do not differentiate between primitive types (int, char, etc.) <strike>and
</strike><span style="background: #FFFF00">and</span> their <strike>corresponding</strike><span style="background: #FFFF00">corresponding
</span> wrapper types (Integer, Character, etc.). <strike>Primitive
</strike><span style="background: #FFFF00">Primitive</span> types will be replaced with their <strike>wrapper</strike><span style="background: #FFFF00">wrapper
</span> types when keys are created.

 @author crazybob@google.com (Bob Lee)</blockquote>
<A NAME="com.google.inject.Key.ctor()"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ctor_changed()" class="hiddenlink">constructor <b>Key()</b></a><br><br><blockquote>Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the <strike>type
</strike><span style="background: #FFFF00">type</span> parameter in <strike>the</strike><span style="background: #FFFF00">the
</span> anonymous class's type hierarchy so we can reconstitute <strike>it
</strike><span style="background: #FFFF00">it</span> at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo}:

 <p>{@code new Key<Foo>() {}}.</blockquote>
<A NAME="com.google.inject.Key.ctor(Annotation)"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ctor_changed(java.lang.annotation.Annotation)" class="hiddenlink">constructor <b>Key(Annotation)</b></a><br><br><blockquote>Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the <strike>type
</strike><span style="background: #FFFF00">type</span> parameter in <strike>the</strike><span style="background: #FFFF00">the
</span> anonymous class's type hierarchy so we can reconstitute <strike>it
</strike><span style="background: #FFFF00">it</span> at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated <strike>with
</strike><span style="background: #FFFF00">with</span> {@code @Bar}:

 <p>{@code new Key<Foo>(new Bar()) {}}.</blockquote>
<A NAME="com.google.inject.Key.ctor(Class&lt;Annotation&gt;)"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ctor_changed(java.lang.Class<? extends java.lang.annotation.Annotation>)" class="hiddenlink">constructor <b>Key(Class&lt;Annotation&gt;)</b></a><br><br><blockquote>Constructs a new key. Derives the type from this class's type parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the <strike>type
</strike><span style="background: #FFFF00">type</span> parameter in <strike>the</strike><span style="background: #FFFF00">the
</span> anonymous class's type hierarchy so we can reconstitute <strike>it
</strike><span style="background: #FFFF00">it</span> at runtime despite erasure.

 <p>Example usage for a binding of type {@code Foo} annotated <strike>with
</strike><span style="background: #FFFF00">with</span> {@code @Bar}:

 <p>{@code new Key<Foo>(Bar.class) {}}.</blockquote>
<A NAME="com.google.inject.Key.dmethod.ofType(Class&lt;T&gt;)"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ofType_changed(java.lang.Class<T>)" class="hiddenlink">Key&lt;T&gt; <b>ofType(Class&lt;T&gt;)</b></a><br><br><blockquote>Returns a new key of the specified type with the same annotation as <strike>this
</strike><span style="background: #FFFF00">this</span> key.

 @since 3.0</blockquote>
<A NAME="com.google.inject.Key.dmethod.ofType(Type)"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ofType_changed(java.lang.reflect.Type)" class="hiddenlink">Key&lt;?&gt; <b>ofType(Type)</b></a><br><br><blockquote>Returns a new key of the specified type with the same annotation as <strike>this
</strike><span style="background: #FFFF00">this</span> key.

 @since 3.0</blockquote>
<A NAME="com.google.inject.Key.dmethod.ofType(TypeLiteral&lt;T&gt;)"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.ofType_changed(com.google.inject.TypeLiteral<T>)" class="hiddenlink">Key&lt;T&gt; <b>ofType(TypeLiteral&lt;T&gt;)</b></a><br><br><blockquote>Returns a new key of the specified type with the same annotation as <strike>this
</strike><span style="background: #FFFF00">this</span> key.

 @since 3.0</blockquote>
<A NAME="com.google.inject.Key.dmethod.withoutAttributes()"></A><a href="com.google.inject.Key.html" class="hiddenlink">Class <b>Key</b></a>, <a href="com.google.inject.Key.html#com.google.inject.Key.withoutAttributes_changed()" class="hiddenlink">Key&lt;T&gt; <b>withoutAttributes()</b></a><br><br><blockquote>Returns this key without annotation attributes, i.e. with only <strike>the
</strike><span style="background: #FFFF00">the</span> annotation type.

 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.MembersInjector!class"></A><a href="com.google.inject.MembersInjector.html" class="hiddenlink">Class <b>MembersInjector</b></a><br><br><blockquote>Injects dependencies into the fields and methods on instances of type {@code T}. Ignores the
 presence or absence of an injectable constructor.

 @param <T> type to inject members <strike>of

</strike><span style="background: #FFFF00">of
</span> @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Module!class"></A><a href="com.google.inject.Module.html" class="hiddenlink">Class <b>Module</b></a><br><br><blockquote>A module contributes configuration information, typically <strike>interface
</strike><span style="background: #FFFF00">interface</span> bindings, which will be <strike>used</strike><span style="background: #FFFF00">used
</span> to create an <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Module/Injector.html"><TT>Injector</TT></A>. A Guice-<strike>based
</strike><span style="background: #FFFF00">based</span> application is ultimately composed of little <strike>more</strike><span style="background: #FFFF00">more
</span> than a set <strike>of
</strike><span style="background: #FFFF00">of</span> {@code Module}s and some bootstrapping code.

 <p>Your Module classes can use a more streamlined syntax by <strike>extending
</strike><span style="background: #FFFF00">extending</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Module/AbstractModule.html"><TT>AbstractModule</TT></A><span style="background: #FFFF00">
</span> rather than implementing this interface directly.

 <p>In addition to the bindings configured via <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Module/.html#configure"><TT>.configure</TT></A>, <strike>bindings
</strike><span style="background: #FFFF00">bindings</span> will be created <strike>for</strike><span style="background: #FFFF00">for
</span> all methods annotated with {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Module/Provides.html"><TT>Provides</TT></A>.<strike>
</strike> Use scope and binding annotations <strike>on</strike><span style="background: #FFFF00">on
</span> these methods to configure <strike>the
</strike><span style="background: #FFFF00">the</span> bindings.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.OutOfScopeException!class"></A><a href="com.google.inject.OutOfScopeException.html" class="hiddenlink">Class <b>OutOfScopeException</b></a><br><br><blockquote>Thrown from <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/OutOfScopeException/Provider.html#get"><TT>Provider.get</TT></A> when an attempt is made to access a <strike>scoped
</strike><span style="background: #FFFF00">scoped</span> object while <strike>the</strike><span style="background: #FFFF00">the
</span> scope in question is not currently active.

 @author kevinb@google.com (Kevin Bourrillion)
 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.PrivateBinder!class"></A><a href="com.google.inject.PrivateBinder.html" class="hiddenlink">Class <b>PrivateBinder</b></a><br><br><blockquote>Returns a binder whose configuration information is hidden from its environment by default. See
 <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateBinder/com/google/inject/PrivateModule.html"><TT>PrivateModule</TT></A> for details.<strike>
 
</strike><span style="background: #FFFF00">

</span> @author jessewilson@google.com (Jesse Wilson)
 @since 2.0</blockquote>
<A NAME="com.google.inject.PrivateBinder.dmethod.expose(Class&lt;?&gt;)"></A><a href="com.google.inject.PrivateBinder.html" class="hiddenlink">Class <b>PrivateBinder</b></a>, <a href="com.google.inject.PrivateBinder.html#com.google.inject.PrivateBinder.expose_changed(java.lang.Class<?>)" class="hiddenlink">AnnotatedElementBuilder <b>expose(Class&lt;?&gt;)</b></a><br><br><blockquote>Makes a binding for {@code type} available to the enclosing environment. Use <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/binder/AnnotatedElementBuilder.html#annotatedWith(Class)"><TT>annotatedWith()</TT></A> <strike>to</strike><span style="background: #FFFF00">to
</span> expose {@code type} with <strike>a
</strike><span style="background: #FFFF00">a</span> binding annotation.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.PrivateModule!class"></A><a href="com.google.inject.PrivateModule.html" class="hiddenlink">Class <b>PrivateModule</b></a><br><br><blockquote>A module whose configuration information is hidden from its environment by default. Only bindings
 that are explicitly exposed will be available to other modules and to the users of the injector.
 This module may expose the bindings it creates and the bindings of the modules it installs.

 <p>A private module can be nested within a regular module or within another private module using
 <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateModule/Binder.html#install"><TT>install()</TT></A>. <strike> </strike>Its bindings live in a new environment that inherits bindings,
 type converters, scopes, and interceptors from the surrounding ("parent") environment. <strike> </strike>When you
 nest multiple private modules, the result is a tree of environments where the injector's
 environment is the root.

 <p>Guice EDSL bindings can be exposed with <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateModule/.html#expose(Class)"><TT>expose()</TT></A>. {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateModule/com/google/inject/Provides.html"><TT>Provides</TT></A> bindings can be exposed with the {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateModule/Exposed.html"><TT>Exposed</TT></A><span style="background: #FFFF00">
</span> annotation:

 <pre>
 public class FooBarBazModule extends PrivateModule {
   protected void configure() {
     bind(Foo.class).to(RealFoo.class);
     expose(Foo.class);

     install(new TransactionalBarModule());
     expose(Bar.class).annotatedWith(Transactional.class);

     bind(SomeImplementationDetail.class);
     install(new MoreImplementationDetailsModule());
   }

   {@literal @}Provides {@literal @}Exposed
   public Baz provideBaz() {
     return new SuperBaz();
   }
 }
 </pre>

 <p>Private modules are implemented using <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/PrivateModule/Injector.html#createChildInjector(Module[])"><TT>parent
 injectors</TT></A>. When it can satisfy their dependencies, just-in-time bindings will be created in the
 root environment. Such bindings are shared among all environments in the tree.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>The scope of a binding is constrained to its environment. A singleton bound in a private
 module will be unique to its environment. But a binding for the same type in a different private
 module will yield a different instance.

 <p>A shared binding that injects the {@code Injector} gets the root injector, which only has
 access to bindings in the root environment. An explicit binding that injects the {@code Injector}
 gets access to all bindings in the child environment.

 <p>To promote a just-in-time binding to an explicit binding, bind it:<strike>
</strike><span style="background: #FFFF00">

</span> <pre>
   bind(FooImpl.class);
 </pre>

 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0</blockquote>
<A NAME="com.google.inject.PrivateModule.dmethod.bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])"></A><a href="com.google.inject.PrivateModule.html" class="hiddenlink">Class <b>PrivateModule</b></a>, <a href="com.google.inject.PrivateModule.html#com.google.inject.PrivateModule.bindInterceptor_changed(com.google.inject.matcher.Matcher<? super java.lang.Class<?>>, com.google.inject.matcher.Matcher<? super java.lang.reflect.Method>, org.aopalliance.intercept.MethodInterceptor[])" class="hiddenlink">void <b>bindInterceptor(Matcher&lt;Class&lt;?&gt;&gt;, Matcher&lt;Method&gt;, MethodInterceptor[])</b></a><br><br><blockquote>@see Binder#bindInterceptor(com.google.inject.matcher.Matcher,<span style="background: #FFFF00">
</span> <span style="background: #FFFF00">    </span>com.google.inject.matcher.Matcher, org.aopalliance.intercept.MethodInterceptor[])</blockquote>
<A NAME="com.google.inject.PrivateModule.dmethod.convertToTypes(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeConverter)"></A><a href="com.google.inject.PrivateModule.html" class="hiddenlink">Class <b>PrivateModule</b></a>, <a href="com.google.inject.PrivateModule.html#com.google.inject.PrivateModule.convertToTypes_changed(com.google.inject.matcher.Matcher<? super com.google.inject.TypeLiteral<?>>, com.google.inject.spi.TypeConverter)" class="hiddenlink">void <b>convertToTypes(Matcher&lt;TypeLiteral&lt;?&gt;&gt;, TypeConverter)</b></a><br><br><blockquote>@see Binder#convertToTypes(com.google.inject.matcher.Matcher,<span style="background: #FFFF00">
</span> <span style="background: #FFFF00">    </span>com.google.inject.spi.TypeConverter)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Provider!class"></A><a href="com.google.inject.Provider.html" class="hiddenlink">Class <b>Provider</b></a><br><br><blockquote>An object capable of providing instances of type {@code T}. Providers are used in numerous ways
 by Guice:

 <ul>
 <li>When the default means for obtaining instances (an injectable or parameterless constructor)
 <span style="background: #FFFF00">    </span>is insufficient for a particular binding, the module can specify a custom {@code Provider}
 <span style="background: #FFFF00">    </span>instead, to control exactly how Guice creates or obtains instances for the binding.<strike>

</strike><span style="background: #FFFF00">
</span> <li>An implementation class may always choose to have a {@code Provider<T>} instance injected,
 <span style="background: #FFFF00">    </span>rather than having a {@code T} injected directly. <strike> </strike>This may give you access to multiple
 <span style="background: #FFFF00">    </span>instances, instances you wish to safely mutate and discard, instances which are out of scope
 <span style="background: #FFFF00">    </span>(e.g. using a {@code @RequestScoped} object from within a {@code @SessionScoped} object), or
 <span style="background: #FFFF00">    </span>instances that will be initialized lazily.<strike>

</strike><span style="background: #FFFF00">
</span> <li>A custom <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Provider/Scope.html"><TT>Scope</TT></A> is implemented as a decorator of {@code Provider<T>}, which decides
 <span style="background: #FFFF00">    </span>when to delegate to the backing provider and when to provide the instance some other way.<strike>

</strike><span style="background: #FFFF00">
</span> <li>The <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Provider/Injector.html"><TT>Injector</TT></A> offers access to the {@code Provider<T>} it uses to fulfill <strike>requests
</strike><span style="background: #FFFF00">requests</span> <strike>for</strike><span style="background: #FFFF00">for
    </span> a given key, via the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Provider/Injector.html#getProvider"><TT>Injector.getProvider</TT></A> methods.
 </ul>

 @param <T> the type of object this <strike>provides

</strike><span style="background: #FFFF00">provides
</span> @author crazybob@google.com (Bob Lee)</blockquote>
<A NAME="com.google.inject.Provider.dmethod.get()"></A><a href="com.google.inject.Provider.html" class="hiddenlink">Class <b>Provider</b></a>, <a href="com.google.inject.Provider.html#com.google.inject.Provider.get_changed()" class="hiddenlink">T <b>get()</b></a><br><br><blockquote>Provides an instance of {@code T}.<strike> Must never return {@code null}.</strike>

 @throws OutOfScopeException when an attempt is made to access a scoped object while the scope
     in question is not currently active
 @throws ProvisionException if an instance cannot be provided. Such exceptions include messages
     and throwables to describe why provision failed.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.ProvisionException!class"></A><a href="com.google.inject.ProvisionException.html" class="hiddenlink">Class <b>ProvisionException</b></a><br><br><blockquote>Indicates that there was a runtime failure while providing an instance.<strike>

</strike><span style="background: #FFFF00">


</span> @author kevinb@google.com (Kevin Bourrillion)
 @author jessewilson@google.com (Jesse Wilson)
 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Scope!class"></A><a href="com.google.inject.Scope.html" class="hiddenlink">Class <b>Scope</b></a><br><br><blockquote>A scope is a level of visibility that instances provided by Guice may have.<strike>
</strike> By default, <strike>an</strike><span style="background: #FFFF00">an
</span> instance created by the <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Scope/Injector.html"><TT>Injector</TT></A> has <i>no scope</i>,<strike>
</strike> meaning it has no state from <strike>the</strike><span style="background: #FFFF00">the
</span> framework's perspective -- <strike>the
</strike><span style="background: #FFFF00">the</span> {@code Injector} creates it, injects it once into the class <strike>that</strike><span style="background: #FFFF00">that
</span> required it,<strike>
</strike> and then immediately forgets it. Associating a scope with a <strike>particular
 binding</strike><span style="background: #FFFF00">particular binding
</span> allows the created instance to be "remembered" and possibly <strike>used
</strike><span style="background: #FFFF00">used</span> again for other injections.

 <p>An example of a scope is <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Scope/Scopes.html#SINGLETON"><TT>Scopes.SINGLETON</TT></A>.

 @author crazybob@google.com (Bob Lee)</blockquote>
<A NAME="com.google.inject.Scope.dmethod.scope(Key&lt;T&gt;, Provider&lt;T&gt;)"></A><a href="com.google.inject.Scope.html" class="hiddenlink">Class <b>Scope</b></a>, <a href="com.google.inject.Scope.html#com.google.inject.Scope.scope_changed(com.google.inject.Key<T>, com.google.inject.Provider<T>)" class="hiddenlink">Provider&lt;T&gt; <b>scope(Key&lt;T&gt;, Provider&lt;T&gt;)</b></a><br><br><blockquote>Scopes a provider. The returned provider returns objects from this scope.<strike>
</strike> If an object does <strike>not</strike><span style="background: #FFFF00">not
</span> exist in this scope, the provider can use the <strike>given
</strike><span style="background: #FFFF00">given</span> unscoped provider to retrieve one.

 <p>Scope implementations are strongly encouraged to <strike>override
</strike><span style="background: #FFFF00">override</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Object.html#toString"><TT>Object.toString</TT></A> in <strike>the</strike><span style="background: #FFFF00">the
</span> returned provider and include the <strike>backing
</strike><span style="background: #FFFF00">backing</span> provider's {@code toString()} output.

 @param key binding key
 @param unscoped locates an instance when one doesn't already exist in <strike>this
 </strike><span style="background: #FFFF00">this</span> scope.
 @return a new provider which only delegates to the given unscoped <strike>provider
 </strike><span style="background: #FFFF00">provider</span> when an instance <strike>of</strike><span style="background: #FFFF00">of
</span> <span style="background: #FFFF00">    </span>the requested object doesn't already exist in <strike>this
 </strike><span style="background: #FFFF00">this</span> scope</blockquote>
<A NAME="com.google.inject.Scope.dmethod.toString()"></A><a href="com.google.inject.Scope.html" class="hiddenlink">Class <b>Scope</b></a>, <a href="com.google.inject.Scope.html#com.google.inject.Scope.toString_changed()" class="hiddenlink">String <b>toString()</b></a><br><br><blockquote>A short but useful description of this scope. <strike> </strike>For comparison, the <strike>standard
</strike><span style="background: #FFFF00">standard</span> scopes that <strike>ship</strike><span style="background: #FFFF00">ship
</span> with guice use the <strike>descriptions
</strike><span style="background: #FFFF00">descriptions</span> {@code "Scopes.SINGLETON"}, {@code "ServletScopes.SESSION"} and
 {@code "ServletScopes.REQUEST"}.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.ScopeAnnotation!class"></A><a href="com.google.inject.ScopeAnnotation.html" class="hiddenlink">Class <b>ScopeAnnotation</b></a><br><br><blockquote>Annotates annotations which are used for scoping. Only one such <strike>annotation
</strike><span style="background: #FFFF00">annotation</span> may apply to a <strike>single</strike><span style="background: #FFFF00">single
</span> implementation class. You must also annotate <strike>scope
</strike><span style="background: #FFFF00">scope</span> annotations with {@code @Retention(RUNTIME)}.<span style="background: #FFFF00">
</span> For example:

 <pre>
   {@code @}Retention(RUNTIME)
   {@code @}Target(TYPE, METHOD)
   {@code @}ScopeAnnotation
   public {@code @}interface SessionScoped {}
 </pre>

 @author crazybob@google.com (Bob Lee)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Scopes.dmethod.isCircularProxy(Object)"></A><a href="com.google.inject.Scopes.html" class="hiddenlink">Class <b>Scopes</b></a>, <a href="com.google.inject.Scopes.html#com.google.inject.Scopes.isCircularProxy_changed(java.lang.Object)" class="hiddenlink">boolean <b>isCircularProxy(Object)</b></a><br><br><blockquote>Returns true if the object is a proxy for a circular dependency,<strike>
</strike> constructed by Guice <strike>because</strike><span style="background: #FFFF00">because
</span> it encountered a circular dependency. <strike>Scope
</strike><span style="background: #FFFF00">Scope</span> implementations should be careful to <b>not <strike>cache</strike><span style="background: #FFFF00">cache
</span> circular proxies</b>,<strike>
</strike> because the proxies are not intended for general purpose use. (They are
 designed just to fulfill the immediate injection, not all injections.<strike>
</strike> Caching them can lead <strike>to</strike><span style="background: #FFFF00">to
</span> IllegalArgumentExceptions or ClassCastExceptions.)

 @since 4.0</blockquote>
<A NAME="com.google.inject.Scopes.field.NO_SCOPE"></A><a href="com.google.inject.Scopes.html" class="hiddenlink">Class <b>Scopes</b></a>, <a href="com.google.inject.Scopes.html#com.google.inject.Scopes.NO_SCOPE" class="hiddenlink">Scope <b>NO_SCOPE</b></a><br><br><blockquote>No scope; the same as not applying any scope at all. <strike> </strike>Each time <strike>the
</strike><span style="background: #FFFF00">the</span> Injector obtains an <strike>instance</strike><span style="background: #FFFF00">instance
</span> of an object with "no scope", it injects <strike>this
</strike><span style="background: #FFFF00">this</span> instance then immediately forgets it. <strike> </strike>When <strike>the</strike><span style="background: #FFFF00">the
</span> next request for the <strike>same
</strike><span style="background: #FFFF00">same</span> binding arrives it will need to obtain the instance over again.

 <p>This exists only in case a class has been annotated with a <strike>scope
</strike><span style="background: #FFFF00">scope</span> annotation such as <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Singleton.html"><TT>@Singleton</TT></A>, and you need to <strike>override
</strike><span style="background: #FFFF00">override</span> this to "no scope" in your binding.

 @since 2.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.Singleton!class"></A><a href="com.google.inject.Singleton.html" class="hiddenlink">Class <b>Singleton</b></a><br><br><blockquote>Apply this to implementation classes when you want only one <strike>instance
</strike><span style="background: #FFFF00">instance</span> (per <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/Singleton/Injector.html"><TT>Injector</TT></A>) to <strike>be</strike><span style="background: #FFFF00">be
</span> reused for all injections for that binding.

 @author crazybob@google.com (Bob Lee)</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.TypeLiteral!class"></A><a href="com.google.inject.TypeLiteral.html" class="hiddenlink">Class <b>TypeLiteral</b></a><br><br><blockquote>Represents a generic type {@code T}. Java doesn't yet provide a way <strike>to
</strike><span style="background: #FFFF00">to</span> represent generic types,<span style="background: #FFFF00">
</span> so this class does. Forces clients to create <strike>a
</strike><span style="background: #FFFF00">a</span> subclass of this class which enables retrieval <span style="background: #FFFF00">of
 </span>the type information even <strike>at
</strike><span style="background: #FFFF00">at</span> runtime.

 <p>For example, to create a type literal for {@code List<String>}, you <strike>can
</strike><span style="background: #FFFF00">can</span> create an <strike>empty</strike><span style="background: #FFFF00">empty
</span> anonymous inner class:

 <p><strike>
 </strike>{@code TypeLiteral<List<String>> list = new TypeLiteral<List<String>>() {};}

 <p>Along with modeling generic types, this class can resolve type parameters.<strike>
</strike> For example, <strike>to</strike><span style="background: #FFFF00">to
</span> figure out what type {@code keySet()} returns on a {@<strike>code
</strike><span style="background: #FFFF00">code</span> Map<Integer, String>}, use this code:<strike>  </strike><span style="background: #FFFF00">

</span> <pre>{@<strike>code

  </strike><span style="background: #FFFF00">code
</span> TypeLiteral<Map<Integer, String>> mapType
     <strike>  </strike>= new TypeLiteral<Map<Integer, String>>() {};
 <strike>  </strike>TypeLiteral<> keySetType
     <strike>  </strike>= mapType.getReturnType(Map.class.getMethod("keySet"));
 <strike>  </strike>System.out.println(keySetType); // prints "Set<Integer>"<span style="background: #FFFF00">
 </span>}</pre>

 @author crazybob@google.com (Bob Lee)
 @author jessewilson@google.com (Jesse Wilson)</blockquote>
<A NAME="com.google.inject.TypeLiteral.ctor()"></A><a href="com.google.inject.TypeLiteral.html" class="hiddenlink">Class <b>TypeLiteral</b></a>, <a href="com.google.inject.TypeLiteral.html#com.google.inject.TypeLiteral.ctor_changed()" class="hiddenlink">constructor <b>TypeLiteral()</b></a><br><br><blockquote>Constructs a new type literal. Derives represented class from <strike>type
</strike><span style="background: #FFFF00">type</span> parameter.

 <p>Clients create an empty anonymous subclass. Doing so embeds the <strike>type
</strike><span style="background: #FFFF00">type</span> parameter in <strike>the</strike><span style="background: #FFFF00">the
</span> anonymous class's type hierarchy so we can reconstitute <strike>it
</strike><span style="background: #FFFF00">it</span> at runtime despite erasure.</blockquote>
<A NAME="com.google.inject.TypeLiteral.dmethod.getRawType()"></A><a href="com.google.inject.TypeLiteral.html" class="hiddenlink">Class <b>TypeLiteral</b></a>, <a href="com.google.inject.TypeLiteral.html#com.google.inject.TypeLiteral.getRawType_changed()" class="hiddenlink">Class&lt;? super T&gt; <b>getRawType()</b></a><br><br><blockquote>Returns the raw (non-generic) type for this type.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike>@since 2.0</blockquote>
<hr align="left" width="100%">

</BODY>
</HTML>
