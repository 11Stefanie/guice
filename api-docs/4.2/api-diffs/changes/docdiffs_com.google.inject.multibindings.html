<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<HTML>
<HEAD>
<meta name="generator" content="JDiff v1.1.1">
<!-- Generated by the JDiff Javadoc doclet -->
<!-- (http://www.jdiff.org) -->
<meta name="description" content="JDiff is a Javadoc doclet which generates an HTML report of all the packages, classes, constructors, methods, and fields which have been removed, added or changed in any way, including their documentation, when two APIs are compared.">
<meta name="keywords" content="diff, jdiff, javadiff, java diff, java difference, API difference, difference between two APIs, API diff, Javadoc, doclet">
<LINK REL="stylesheet" TYPE="text/css" HREF="../stylesheet-jdiff.css" TITLE="Style">
<TITLE>
com.google.inject.multibindings Documentation Differences
</TITLE>
</HEAD>
<BODY>
<!-- Start of nav bar -->
<TABLE summary="Navigation bar" BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
  <TABLE summary="Navigation bar" BORDER="0" CELLPADDING="0" CELLSPACING="3">
    <TR ALIGN="center" VALIGN="top">
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/package-summary.html" target="_top"><FONT CLASS="NavBarFont1"><B><tt>4.2</tt></B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="changes-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Package</FONT>&nbsp;</TD>
      <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1"> &nbsp;<FONT CLASS="NavBarFont1">Class</FONT>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="docdiffs_index.html"><FONT CLASS="NavBarFont1"><B>Text Changes</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_statistics.html"><FONT CLASS="NavBarFont1"><B>Statistics</B></FONT></A>&nbsp;</TD>
      <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1"> <A HREF="jdiff_help.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
    </TR>
  </TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM><b>Generated by<br><a href="http://www.jdiff.org" class="staysblack" target="_top">JDiff</a></b></EM></TD>
</TR>
<TR>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="docdiffs_com.google.inject.matcher.html"><B>PREV PACKAGE</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.name.html"><B>NEXT PACKAGE</B></A>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  <A HREF="../changes.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
  &nbsp;<A HREF="docdiffs_com.google.inject.multibindings.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell2">&nbsp;</TD>
</TR>
</TABLE>
<HR>
<!-- End of nav bar -->
<h2>
com.google.inject.multibindings Documentation Differences
</h2>

<blockquote>
This file contains all the changes in documentation in the package <code>com.google.inject.multibindings</code> as colored differences.
Deletions are shown <strike>like this</strike>, and
additions are shown <span style="background: #FFFF00">like this</span>.
</blockquote>
<blockquote>
If no deletions or additions are shown in an entry, the HTML tags will be what has changed. The <i>new</i> HTML tags are shown in the differences. 
If no documentation existed, and then some was added in a later version, this change is noted in the appropriate class pages of differences, but the change is not shown on this page. Only changes in existing text are shown here. 
Similarly, documentation which was inherited from another class or interface is not shown here.
</blockquote>
<blockquote>
 Note that an HTML error in the new documentation may cause the display of other documentation changes to be presented incorrectly. For instance, failure to close a &lt;code&gt; tag will cause all subsequent paragraphs to be displayed differently.
</blockquote>
<hr>

<A NAME="com.google.inject.multibindings.MapBinder!class"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a><br><br><blockquote>An API to bind multiple map entries separately, only to later inject them <strike>as
</strike><span style="background: #FFFF00">as</span> a complete map.<span style="background: #FFFF00">
</span> MapBinder is intended for use in your application's module:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     MapBinder&lt;String, Snack&gt; mapbinder
         = MapBinder.newMapBinder(binder(), String.class, Snack.class);
     mapbinder.addBinding("twix").toInstance(new Twix());
     mapbinder.addBinding("snickers").toProvider(SnickersProvider.class);
     mapbinder.addBinding("skittles").to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapBinder/Map.html"><TT>Map</TT></A>{@code <String, Snack>} can now <strike>be
</strike><span style="background: #FFFF00">be</span> injected:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Snack&gt; snacks) { ... }
 }</code></pre>

 <p>In addition to binding {@code Map<K, V>}, a mapbinder will also <strike>bind
</strike><span style="background: #FFFF00">bind</span> {@code Map<K,
 Provider<V>>} for lazy value provision:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Map&lt;String, Provider&lt;Snack&gt;&gt; snackProviders) { ... }
 }</code></pre>

 <p>Contributing mapbindings from different modules is supported. For example,<strike>
</strike> it is okay to <strike>have</strike><span style="background: #FFFF00">have
</span> both {@code CandyModule} and {@code ChipsModule} <strike>both
</strike><span style="background: #FFFF00">both</span> create their own {@code MapBinder<String,
 Snack>}, and to each <strike>contribute
</strike><span style="background: #FFFF00">contribute</span> bindings to the snacks map. When that map is injected, it <strike>will contain
</strike><span style="background: #FFFF00">will
 contain</span> entries from both modules.

 <p>The map's iteration order is consistent with the binding order. This <strike>is
</strike><span style="background: #FFFF00">is</span> convenient <strike>when</strike><span style="background: #FFFF00">when
</span> multiple elements are contributed by the same module <strike>because
</strike><span style="background: #FFFF00">because</span> that module can order its <strike>bindings</strike><span style="background: #FFFF00">bindings
</span> appropriately. Avoid relying on <strike>the
</strike><span style="background: #FFFF00">the</span> iteration order of elements contributed by different modules,<span style="background: #FFFF00">
</span> since there <strike>is
</strike><span style="background: #FFFF00">is</span> no equivalent mechanism to order modules.

 <p>The map is unmodifiable. <strike> </strike>Elements can only be added to the map <strike>by
</strike><span style="background: #FFFF00">by</span> configuring the MapBinder.<strike> </strike><span style="background: #FFFF00">
</span> Elements can never be removed from the map.

 <p>Values are resolved at map injection time. If a value is bound to <strike>a
</strike><span style="background: #FFFF00">a</span> provider, that provider'<strike>s</strike><span style="background: #FFFF00">s
</span> get method will be called each time the map <strike>is
</strike><span style="background: #FFFF00">is</span> injected (unless the binding is also scoped, or <strike>a</strike><span style="background: #FFFF00">a
</span> map of providers is injected).

 <p>Annotations are used to create different maps of the same key/<strike>value
</strike><span style="background: #FFFF00">value</span> type. Each <strike>distinct</strike><span style="background: #FFFF00">distinct
</span> annotation gets its own independent map.

 <p><strong>Keys must be distinct.</strong> If the same key is bound more <strike>than
</strike><span style="background: #FFFF00">than</span> once, map <strike>injection</strike><span style="background: #FFFF00">injection
</span> will fail. However, use <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapBinder/.html#permitDuplicates()"><TT>.permitDuplicates()</TT></A> <strike>in
</strike><span style="background: #FFFF00">in</span> order to allow duplicate keys; <strike>extra</strike><span style="background: #FFFF00">extra
</span> bindings to {@code Map<K, Set<V>>} <strike>and
</strike><span style="background: #FFFF00">and</span> {@code Map<K, Set<Provider<V>>} will be added.

 <p><strong>Keys must be non-null.</strong> {@code addBinding(null)} <strike>will
</strike><span style="background: #FFFF00">will</span> throw an <strike>unchecked</strike><span style="background: #FFFF00">unchecked
</span> exception.

 <p><strong>Values must be non-null to use map injection.</strong> If <strike>any
</strike><span style="background: #FFFF00">any</span> value is null, <strike>map</strike><span style="background: #FFFF00">map
</span> injection will fail (although injecting a map of <strike>providers
</strike><span style="background: #FFFF00">providers</span> will not).

 @author dpb@google.com (David P. Baker)</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.addBinding(K)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.addBinding_changed(K)" class="hiddenlink">LinkedBindingBuilder&lt;V&gt; <b>addBinding(K)</b></a><br><br><blockquote>Returns a binding builder used to add a new entry in the map. <strike>Each
</strike><span style="background: #FFFF00">Each</span> key must be distinct (<strike>and</strike><span style="background: #FFFF00">and
</span> non-null). Bound providers will be evaluated <strike>each
</strike><span style="background: #FFFF00">each</span> time the map is injected.

 <p>It is an error to call this method without also calling one of <strike>the
</strike><span style="background: #FFFF00">the</span> {@code to} methods on <strike>the</strike><span style="background: #FFFF00">the
</span> returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} <strike>method
</strike><span style="background: #FFFF00">method</span> to specify a <strike>binding</strike><span style="background: #FFFF00">binding
</span> scope.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, java.lang.Class<K>, java.lang.Class<V>)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with no binding annotation.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;, Annotation)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, java.lang.Class<K>, java.lang.Class<V>, java.lang.annotation.Annotation)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;, Annotation)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with {@code annotation}.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;, Class&lt;Annotation&gt;)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, java.lang.Class<K>, java.lang.Class<V>, java.lang.Class<? extends java.lang.annotation.Annotation>)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, Class&lt;K&gt;, Class&lt;V&gt;, Class&lt;Annotation&gt;)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with {@code annotationType}.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, com.google.inject.TypeLiteral<K>, com.google.inject.TypeLiteral<V>)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with no binding annotation.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;, Annotation)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, com.google.inject.TypeLiteral<K>, com.google.inject.TypeLiteral<V>, java.lang.annotation.Annotation)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;, Annotation)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with {@code annotation}.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;, Class&lt;Annotation&gt;)"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.newMapBinder_changed(com.google.inject.Binder, com.google.inject.TypeLiteral<K>, com.google.inject.TypeLiteral<V>, java.lang.Class<? extends java.lang.annotation.Annotation>)" class="hiddenlink">MapBinder&lt;K, V&gt; <b>newMapBinder(Binder, TypeLiteral&lt;K&gt;, TypeLiteral&lt;V&gt;, Class&lt;Annotation&gt;)</b></a><br><br><blockquote>Returns a new mapbinder that collects entries of {@code keyType}/{@code valueType} in <strike>a
</strike><span style="background: #FFFF00">a</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Map.html"><TT>Map</TT></A> that is itself bound with {@code annotationType}.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinder.dmethod.permitDuplicates()"></A><a href="com.google.inject.multibindings.MapBinder.html" class="hiddenlink">Class <b>MapBinder</b></a>, <a href="com.google.inject.multibindings.MapBinder.html#com.google.inject.multibindings.MapBinder.permitDuplicates_changed()" class="hiddenlink">MapBinder&lt;K, V&gt; <b>permitDuplicates()</b></a><br><br><blockquote>Configures the {@code MapBinder} to handle duplicate entries.<strike>
</strike><span style="background: #FFFF00">

</span> <p>When multiple equal keys are bound, the value that gets included in the map <strike>is
</strike><span style="background: #FFFF00">is</span> arbitrary.<strike>
</strike><span style="background: #FFFF00">

</span> <p>In addition to the {@code Map<K, V>} and {@code Map<K, Provider<V>>}<strike>
</strike> maps that are <strike>normally</strike><span style="background: #FFFF00">normally
</span> bound, a {@code Map<K, Set<V>>} <strike>and
</strike><span style="background: #FFFF00">and</span> {@code Map<K, Set<Provider<V>>>} are <em>also</em> bound,<span style="background: #FFFF00">
</span> which <strike>contain
</strike><span style="background: #FFFF00">contain</span> all values bound to each key.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>When multiple modules contribute elements to the map, this <strike>configuration
</strike><span style="background: #FFFF00">configuration</span> option impacts <strike>all</strike><span style="background: #FFFF00">all
</span> of them.

 @return this map binder
 @since 3.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.MapBinderBinding!class"></A><a href="com.google.inject.multibindings.MapBinderBinding.html" class="hiddenlink">Class <b>MapBinderBinding</b></a><br><br><blockquote>A binding for a MapBinder.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>Although MapBinders may be injected through a variety of generic types (Map&lt;K, V>, Map
 &lt;K, Provider&lt;V>>, Map&lt;K, Set&lt;V>>, Map<K, Set&lt; Provider&lt;V>>, and <strike>even</strike><span style="background: #FFFF00">even
</span> Set&lt;Map.Entry&lt;K, Provider&lt;V>>), <strike>a
</strike><span style="background: #FFFF00">a</span> MapBinderBinding exists only on the Binding <strike>associated</strike><span style="background: #FFFF00">associated
</span> with the Map&lt;K, V> key. <strike>Other
</strike><span style="background: #FFFF00">Other</span> bindings can be validated to be derived from <strike>this</strike><span style="background: #FFFF00">this
</span> MapBinderBinding <strike>using
</strike><span style="background: #FFFF00">using</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapBinderBinding/.html#containsElement(Element)"><TT>.containsElement(Element)</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike>@param <T> The fully qualified type of the map, including Map. For example:<strike>
 </strike> <strike>   </strike><code><span style="background: #FFFF00">
</span>     MapBinderBinding&lt;Map&lt;String, Snack>></code>
 <strike>
 </strike>@since 3.0
 @author sameb@google.com (Sam Berlin)</blockquote>
<A NAME="com.google.inject.multibindings.MapBinderBinding.dmethod.containsElement(Element)"></A><a href="com.google.inject.multibindings.MapBinderBinding.html" class="hiddenlink">Class <b>MapBinderBinding</b></a>, <a href="com.google.inject.multibindings.MapBinderBinding.html#com.google.inject.multibindings.MapBinderBinding.containsElement_changed(com.google.inject.spi.Element)" class="hiddenlink">boolean <b>containsElement(Element)</b></a><br><br><blockquote>Returns true if this MapBinder contains the given Element in order to build the map or uses the
 given Element in order to support building and injecting the map. This will work for
 MapBinderBindings retrieved from an injector and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>. Usually this is
 only necessary if you are working with elements retrieved from modules (without an Injector),
 otherwise <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getEntries"><TT>.getEntries</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#permitsDuplicates"><TT>.permitsDuplicates</TT></A> are better options.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If you need to introspect the details of the map, such as the keys, values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and <strike>use
</strike><span style="background: #FFFF00">use</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getEntries()"><TT>.getEntries()</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#permitsDuplicates()"><TT>.permitsDuplicates()</TT></A>.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinderBinding.dmethod.getEntries()"></A><a href="com.google.inject.multibindings.MapBinderBinding.html" class="hiddenlink">Class <b>MapBinderBinding</b></a>, <a href="com.google.inject.multibindings.MapBinderBinding.html#com.google.inject.multibindings.MapBinderBinding.getEntries_changed()" class="hiddenlink">List&lt;Entry&lt;?, Binding&lt;?&gt;&gt;&gt; <b>getEntries()</b></a><br><br><blockquote>Returns all entries in the Map. The returned list of Map.Entries contains the key and a binding
 to the value. Duplicate keys or values will exist as separate Map.Entries in the returned list.
 This is only supported on bindings returned from an injector. This will <strike>throw
</strike><span style="background: #FFFF00">throw</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/UnsupportedOperationException.html"><TT>UnsupportedOperationException</TT></A> if it is called on an element retrieved <strike>from
</strike><span style="background: #FFFF00">from</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The elements will always match the type Map's generic type. For example, if <strike>getMapKey</strike><span style="background: #FFFF00">getMapKey
</span> returns <strike>a
</strike><span style="background: #FFFF00">a</span> key of <code>Map&lt;String, Snack></code>, then this will always return a list <strike>of type
</strike><span style="background: #FFFF00">of
 type</span> <code>List&lt;Map.Entry&lt;String, Binding&lt;Snack>>></code>.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinderBinding.dmethod.getKeyTypeLiteral()"></A><a href="com.google.inject.multibindings.MapBinderBinding.html" class="hiddenlink">Class <b>MapBinderBinding</b></a>, <a href="com.google.inject.multibindings.MapBinderBinding.html#com.google.inject.multibindings.MapBinderBinding.getKeyTypeLiteral_changed()" class="hiddenlink">TypeLiteral&lt;?&gt; <b>getKeyTypeLiteral()</b></a><br><br><blockquote>Returns the TypeLiteral describing the keys of the map.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return <strike>a
</strike><span style="background: #FFFF00">a</span> <code><span style="background: #FFFF00">
 </span>TypeLiteral&lt;String></code>.</blockquote>
<A NAME="com.google.inject.multibindings.MapBinderBinding.dmethod.getValueTypeLiteral()"></A><a href="com.google.inject.multibindings.MapBinderBinding.html" class="hiddenlink">Class <b>MapBinderBinding</b></a>, <a href="com.google.inject.multibindings.MapBinderBinding.html#com.google.inject.multibindings.MapBinderBinding.getValueTypeLiteral_changed()" class="hiddenlink">TypeLiteral&lt;?&gt; <b>getValueTypeLiteral()</b></a><br><br><blockquote>Returns the TypeLiteral describing the values of the map.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The TypeLiteral will always match the type Map's generic type. For example, if getMapKey
 returns a key of <code>Map&lt;String, Snack></code>, then this will always return <strike>a
</strike><span style="background: #FFFF00">a</span> <code><span style="background: #FFFF00">
 </span>TypeLiteral&lt;Snack></code>.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.MapKey!class"></A><a href="com.google.inject.multibindings.MapKey.html" class="hiddenlink">Class <b>MapKey</b></a><br><br><blockquote>Allows users define customized key type annotations for map bindings by annotating an annotation
 of a {@code Map}'s key type. The custom key annotation can be applied to methods also annotated
 with {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapKey/ProvidesIntoMap.html"><TT>ProvidesIntoMap</TT></A>.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>A <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapKey/StringMapKey.html"><TT>StringMapKey</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MapKey/ClassMapKey.html"><TT>ClassMapKey</TT></A> are provided for convenience with maps whose
 keys are strings or classes. For maps with enums or primitive types as keys, you must provide
 your own MapKey annotation, such as this one for an enum:

 <pre>
 {@literal @}MapKey(unwrapValue = true)
 {@literal @}Retention(RUNTIME)
 public {@literal @}interface MyCustomEnumKey {
   MyCustomEnum value();
 }
 </pre>

 You can also use the whole annotation as the key, if {@code unwrapValue=false}.<strike>
</strike> When <strike>unwrapValue</strike><span style="background: #FFFF00">unwrapValue
</span> is false, the annotation type will be the key type for the injected map <strike>and
</strike><span style="background: #FFFF00">and</span> the <strike>annotation</strike><span style="background: #FFFF00">annotation
</span> instances will be the key values. If {@code unwrapValue=true}, the value() <strike>type
</strike><span style="background: #FFFF00">type</span> will be the <strike>key</strike><span style="background: #FFFF00">key
</span> type for injected map and the value() instances will be the keys values.

 @since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.Multibinder!class"></A><a href="com.google.inject.multibindings.Multibinder.html" class="hiddenlink">Class <b>Multibinder</b></a><br><br><blockquote>An API to bind multiple values separately, only to later inject them as <strike>a
</strike><span style="background: #FFFF00">a</span> complete collection.<span style="background: #FFFF00">
</span> Multibinder is intended for use in your application'<strike>s
</strike><span style="background: #FFFF00">s</span> module:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class SnacksModule extends AbstractModule {
   protected void configure() {
     Multibinder&lt;Snack&gt; multibinder
         = Multibinder.newSetBinder(binder(), Snack.class);
     multibinder.addBinding().toInstance(new Twix());
     multibinder.addBinding().toProvider(SnickersProvider.class);
     multibinder.addBinding().to(Skittles.class);
   }
 }</code></pre>

 <p>With this binding, a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/Multibinder/Set.html"><TT>Set</TT></A>{@code <Snack>} can now be injected:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 class SnackMachine {
   {@literal @}Inject
   public SnackMachine(Set&lt;Snack&gt; snacks) { ... }
 }</code></pre>

 If desired, <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/Multibinder/Collection.html"><TT>Collection</TT></A>{@code <Provider<Snack>>} can also be injected.

 <p>Contributing multibindings from different modules is supported. <strike>For
</strike><span style="background: #FFFF00">For</span> example, it is okay <strike>for</strike><span style="background: #FFFF00">for
</span> both {@code CandyModule} and {@code ChipsModule}<strike>
</strike> to create their own {@code Multibinder<Snack>},<span style="background: #FFFF00">
</span> and to each <strike>contribute
</strike><span style="background: #FFFF00">contribute</span> bindings to the set of snacks. When that set is injected, it will contain
 elements from both modules.

 <p>The set's iteration order is consistent with the binding order. This <strike>is
</strike><span style="background: #FFFF00">is</span> convenient <strike>when</strike><span style="background: #FFFF00">when
</span> multiple elements are contributed by the same module <strike>because
</strike><span style="background: #FFFF00">because</span> that module can order its <strike>bindings</strike><span style="background: #FFFF00">bindings
</span> appropriately. Avoid relying on <strike>the
</strike><span style="background: #FFFF00">the</span> iteration order of elements contributed by different modules,<span style="background: #FFFF00">
</span> since there <strike>is
</strike><span style="background: #FFFF00">is</span> no equivalent mechanism to order modules.

 <p>The set is unmodifiable. <strike> </strike>Elements can only be added to the set <strike>by
</strike><span style="background: #FFFF00">by</span> configuring the multibinder.<strike> </strike><span style="background: #FFFF00">
</span> Elements can never be removed from the set.

 <p>Elements are resolved at set injection time. If an element is bound to <strike>a
</strike><span style="background: #FFFF00">a</span> provider, <strike>that</strike><span style="background: #FFFF00">that
</span> provider's get method will be called each time the set <strike>is
</strike><span style="background: #FFFF00">is</span> injected (unless the binding is <strike>also</strike><span style="background: #FFFF00">also
</span> scoped).

 <p>Annotations are be used to create different sets of the same <strike>element
</strike><span style="background: #FFFF00">element</span> type. Each <strike>distinct</strike><span style="background: #FFFF00">distinct
</span> annotation gets its own independent collection <strike>of
</strike><span style="background: #FFFF00">of</span> elements.

 <p><strong>Elements must be distinct.</strong> If multiple bound <strike>elements
</strike><span style="background: #FFFF00">elements</span> have the same value,<span style="background: #FFFF00">
</span> set injection will fail.

 <p><strong>Elements must be non-null.</strong> If any set element is null,<strike>
</strike> set injection <strike>will</strike><span style="background: #FFFF00">will
</span> fail.

 @author jessewilson@google.com (Jesse Wilson)</blockquote>
<A NAME="com.google.inject.multibindings.Multibinder.dmethod.addBinding()"></A><a href="com.google.inject.multibindings.Multibinder.html" class="hiddenlink">Class <b>Multibinder</b></a>, <a href="com.google.inject.multibindings.Multibinder.html#com.google.inject.multibindings.Multibinder.addBinding_changed()" class="hiddenlink">LinkedBindingBuilder&lt;T&gt; <b>addBinding()</b></a><br><br><blockquote>Returns a binding builder used to add a new element in the set. <strike>Each
</strike><span style="background: #FFFF00">Each</span> bound element must have <strike>a</strike><span style="background: #FFFF00">a
</span> distinct value. Bound providers will <strike>be
</strike><span style="background: #FFFF00">be</span> evaluated each time the set is injected.

 <p>It is an error to call this method without also calling one of <strike>the
</strike><span style="background: #FFFF00">the</span> {@code to} methods on <strike>the</strike><span style="background: #FFFF00">the
</span> returned binding builder.

 <p>Scoping elements independently is supported. Use the {@code in} <strike>method
</strike><span style="background: #FFFF00">method</span> to specify a <strike>binding</strike><span style="background: #FFFF00">binding
</span> scope.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.MultibinderBinding!class"></A><a href="com.google.inject.multibindings.MultibinderBinding.html" class="hiddenlink">Class <b>MultibinderBinding</b></a><br><br><blockquote>A binding for a Multibinder.<strike>
 
</strike><span style="background: #FFFF00">

</span> @param <T> The fully qualified type of the set, including Set. For example:<strike>
   </strike> <strike> </strike><code><span style="background: #FFFF00">
</span>     MultibinderBinding&lt;Set&lt;Boolean>></code>
 <strike>
 </strike>@since 3.0
 @author sameb@google.com (Sam Berlin)</blockquote>
<A NAME="com.google.inject.multibindings.MultibinderBinding.dmethod.containsElement(Element)"></A><a href="com.google.inject.multibindings.MultibinderBinding.html" class="hiddenlink">Class <b>MultibinderBinding</b></a>, <a href="com.google.inject.multibindings.MultibinderBinding.html#com.google.inject.multibindings.MultibinderBinding.containsElement_changed(com.google.inject.spi.Element)" class="hiddenlink">boolean <b>containsElement(Element)</b></a><br><br><blockquote>Returns true if this Multibinder uses the given Element. This will be true for bindings that
 derive the elements of the set and other bindings that Multibinder uses internally. This will
 work for MultibinderBindings retrieved from an injector and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>.
 Usually this is only necessary if you are working with elements retrieved from modules (without
 an Injector), otherwise <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getElements"><TT>.getElements</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#permitsDuplicates"><TT>.permitsDuplicates</TT></A> are better options.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If you need to introspect the details of the set, such as the values or if it permits
 duplicates, it is necessary to pass the elements through an Injector and <strike>use
</strike><span style="background: #FFFF00">use</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getElements()"><TT>.getElements()</TT></A> and <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#permitsDuplicates()"><TT>.permitsDuplicates()</TT></A>.</blockquote>
<A NAME="com.google.inject.multibindings.MultibinderBinding.dmethod.getElementTypeLiteral()"></A><a href="com.google.inject.multibindings.MultibinderBinding.html" class="hiddenlink">Class <b>MultibinderBinding</b></a>, <a href="com.google.inject.multibindings.MultibinderBinding.html#com.google.inject.multibindings.MultibinderBinding.getElementTypeLiteral_changed()" class="hiddenlink">TypeLiteral&lt;?&gt; <b>getElementTypeLiteral()</b></a><br><br><blockquote>Returns the TypeLiteral that describes the type of elements in the set.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The elements will always match the type Set's generic type. For example, if <strike>getSetKey</strike><span style="background: #FFFF00">getSetKey
</span> returns <strike>a
</strike><span style="background: #FFFF00">a</span> key of <code>Set&lt;String></code>, then this will always return <strike>a
</strike><span style="background: #FFFF00">a</span> <code><span style="background: #FFFF00">
 </span>TypeLiteral&lt;String></code>.</blockquote>
<A NAME="com.google.inject.multibindings.MultibinderBinding.dmethod.getElements()"></A><a href="com.google.inject.multibindings.MultibinderBinding.html" class="hiddenlink">Class <b>MultibinderBinding</b></a>, <a href="com.google.inject.multibindings.MultibinderBinding.html#com.google.inject.multibindings.MultibinderBinding.getElements_changed()" class="hiddenlink">List&lt;Binding&lt;?&gt;&gt; <b>getElements()</b></a><br><br><blockquote>Returns all bindings that make up the set. This is only supported on bindings returned from an
 injector. This will throw <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/UnsupportedOperationException.html"><TT>UnsupportedOperationException</TT></A> if it is called on an element
 retrieved from <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The elements will always match the type Set's generic type. For example, if <strike>getSetKey</strike><span style="background: #FFFF00">getSetKey
</span> returns <strike>a
</strike><span style="background: #FFFF00">a</span> key of <code>Set&lt;String></code>, then this will always return a list of type
 <code>List&lt;Binding&lt;String>></code>.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.MultibindingsScanner!class"></A><a href="com.google.inject.multibindings.MultibindingsScanner.html" class="hiddenlink">Class <b>MultibindingsScanner</b></a><br><br><blockquote>Scans a module for annotations that signal multibindings, mapbindings, and optional bindings.

 @since 4.<strike>0</strike><span style="background: #FFFF00">0
 @deprecated This functionality is installed by default. All references to this can be safely
     removed. This class will be removed in Guice 4.4</span></blockquote>
<A NAME="com.google.inject.multibindings.MultibindingsScanner.dmethod.asModule()"></A><a href="com.google.inject.multibindings.MultibindingsScanner.html" class="hiddenlink">Class <b>MultibindingsScanner</b></a>, <a href="com.google.inject.multibindings.MultibindingsScanner.html#com.google.inject.multibindings.MultibindingsScanner.asModule_changed()" class="hiddenlink">Module <b>asModule()</b></a><br><br><blockquote>Returns a module that, when installed, will scan all modules for methods with the annotations
 {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/ProvidesIntoMap.html"><TT>ProvidesIntoMap</TT></A>, {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/ProvidesIntoSet.html"><TT>ProvidesIntoSet</TT></A>, and
 {@literal @}<A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/ProvidesIntoOptional.html"><TT>ProvidesIntoOptional</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>This is a convenience method, equivalent to <strike>doing
</strike><span style="background: #FFFF00">doing</span> {@<strike>code</strike><span style="background: #FFFF00">code
</span> binder().scanModulesForAnnotatedMethods(MultibindingsScanner.scanner())}.<span style="background: #FFFF00">

 @deprecated This functionality is now installed by default. All references/installations can be
     eliminated.</span></blockquote>
<A NAME="com.google.inject.multibindings.MultibindingsScanner.dmethod.scanner()"></A><a href="com.google.inject.multibindings.MultibindingsScanner.html" class="hiddenlink">Class <b>MultibindingsScanner</b></a>, <a href="com.google.inject.multibindings.MultibindingsScanner.html#com.google.inject.multibindings.MultibindingsScanner.scanner_changed()" class="hiddenlink">ModuleAnnotatedMethodScanner <b>scanner()</b></a><br><br><blockquote><strike>Returns a ModuleAnnotatedMethodScanner that,</strike><span style="background: #FFFF00">@deprecated</span> <strike>when</strike><span style="background: #FFFF00">This</span> <strike>bound,</strike><span style="background: #FFFF00">method</span> <strike>will scan all modules for
 methods with the annotations</strike><span style="background: #FFFF00">returns an empty scanner since the preexisting functionality is
</span> <strike>{@literal</strike> <strike>@}ProvidesIntoMap,
</strike> <strike>{@literal</strike> <strike>@}ProvidesIntoSet,</strike> <strike>and</strike><span style="background: #FFFF00">installed</span> <strike>{@literal</strike><span style="background: #FFFF00">by</span> <strike>@}ProvidesIntoOptional</strike><span style="background: #FFFF00">default</span>.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.MultibindingsTargetVisitor!class"></A><a href="com.google.inject.multibindings.MultibindingsTargetVisitor.html" class="hiddenlink">Class <b>MultibindingsTargetVisitor</b></a><br><br><blockquote>A visitor for the multibinder extension.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>If your <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MultibindingsTargetVisitor/BindingTargetVisitor.html"><TT>BindingTargetVisitor</TT></A> implements this interface, bindings created by using
 <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MultibindingsTargetVisitor/Multibinder.html"><TT>Multibinder</TT></A>, <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MultibindingsTargetVisitor/MapBinder.html"><TT>MapBinder</TT></A> or <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/MultibindingsTargetVisitor/OptionalBinderBinding.html"><TT>OptionalBinderBinding</TT></A> will be visited through
 this interface.

 @since 3.0
 @author sameb@google.com (Sam Berlin)</blockquote>
<A NAME="com.google.inject.multibindings.MultibindingsTargetVisitor.dmethod.visit(OptionalBinderBinding&lt;? extends T&gt;)"></A><a href="com.google.inject.multibindings.MultibindingsTargetVisitor.html" class="hiddenlink">Class <b>MultibindingsTargetVisitor</b></a>, <a href="com.google.inject.multibindings.MultibindingsTargetVisitor.html#com.google.inject.multibindings.MultibindingsTargetVisitor.visit_changed(com.google.inject.multibindings.OptionalBinderBinding<? extends T>)" class="hiddenlink">V <b>visit(OptionalBinderBinding&lt;? extends T&gt;)</b></a><br><br><blockquote>Visits a binding created through <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/OptionalBinder.html"><TT>OptionalBinder</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike>@since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.OptionalBinder!class"></A><a href="com.google.inject.multibindings.OptionalBinder.html" class="hiddenlink">Class <b>OptionalBinder</b></a><br><br><blockquote>An API to bind optional values, optionally with a default value.<strike>
</strike> OptionalBinder fulfills <strike>two</strike><span style="background: #FFFF00">two
</span> roles:<span style="background: #FFFF00">

</span> <ol>
 <li>It allows a framework to define an injection point that may <strike>or
    </strike><span style="background: #FFFF00">or</span> may not be bound by users.
 <li>It allows a framework to supply a default value that can be <strike>changed
</strike><span style="background: #FFFF00">changed</span> <strike>    </strike>by users.
 </ol><strike>
 
</strike><span style="background: #FFFF00">

</span> <p>When an OptionalBinder is added, it will always supply the bindings:<strike>
</strike> {@code Optional<T>} <strike>and</strike><span style="background: #FFFF00">and
</span> {@code Optional<Provider<T>>}. <strike> If
</strike><span style="background: #FFFF00">If</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/OptionalBinder/.html#setBinding"><TT>.setBinding</TT></A> or <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/OptionalBinder/.html#setDefault"><TT>.setDefault</TT></A> are called, it <strike>will also
</strike><span style="background: #FFFF00">will
 also</span> bind {@code T}.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>{@code setDefault} is intended for use by frameworks that need a <strike>default
</strike><span style="background: #FFFF00">default</span> value. <strike> </strike>User code <strike>can</strike><span style="background: #FFFF00">can
</span> call {@code setBinding} to override the default.<strike>
</strike> <b>Warning: Even if setBinding is called, <strike>the</strike><span style="background: #FFFF00">the
</span> default <strike>binding
</strike><span style="background: #FFFF00">binding</span> will still exist in the object graph. <strike> </strike>If it is a singleton, it will be
 instantiated in {@code Stage.PRODUCTION}.</b><strike>
 
</strike><span style="background: #FFFF00">

</span> <p>If setDefault or setBinding are linked to Providers, the Provider may <strike>return
</strike><span style="background: #FFFF00">return</span> {@code null}. <strike> If</strike><span style="background: #FFFF00">If
</span> it does, the Optional bindings will be absent. <strike> Binding
</strike><span style="background: #FFFF00">Binding</span> setBinding to a Provider that returns <strike>null</strike><span style="background: #FFFF00">null
</span> will not cause <strike>OptionalBinder
</strike><span style="background: #FFFF00">OptionalBinder</span> to fall back to the setDefault binding.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>If neither setDefault nor setBinding are called, it will try to link to <strike>a
</strike><span style="background: #FFFF00">a</span> user-<strike>supplied</strike><span style="background: #FFFF00">supplied
</span> binding of the same type. <strike> </strike>If no binding exists, the <strike>optionals
</strike><span style="background: #FFFF00">optionals</span> will be absent. <strike> </strike>Otherwise, if <strike>a</strike><span style="background: #FFFF00">a
</span> user-supplied binding of that type exists,<strike>
</strike> or if setBinding or setDefault are called, <strike>the</strike><span style="background: #FFFF00">the
</span> optionals will return <strike>present
</strike><span style="background: #FFFF00">present</span> if they are bound to a non-null value.

 <p>Values are resolved at injection time. If a value is bound to <strike>a
</strike><span style="background: #FFFF00">a</span> provider, that provider's <strike>get</strike><span style="background: #FFFF00">get
</span> method will be called each time the <strike>optional
</strike><span style="background: #FFFF00">optional</span> is injected (unless the binding is also scoped, <strike>or</strike><span style="background: #FFFF00">or
</span> an optional of provider <strike>is
</strike><span style="background: #FFFF00">is</span> injected).<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>Annotations are used to create different optionals of the same key/<strike>value
</strike><span style="background: #FFFF00">value</span> type. Each <strike>distinct</strike><span style="background: #FFFF00">distinct
</span> annotation gets its own independent binding.<strike>
  
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class);
   }
 }</code></pre>

 <p>With this module, an <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/OptionalBinder/Optional.html"><TT>Optional</TT></A>{@code <Renamer>} can now <strike>be
</strike><span style="background: #FFFF00">be</span> injected. <strike> </strike>With no <strike>other</strike><span style="background: #FFFF00">other
</span> bindings, the optional will be absent.<strike>
</strike> Users can specify bindings in one of two ways:<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>Option 1:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     bind(Renamer.class).to(ReplacingRenamer.class);
   }
 }</code></pre><strike>
 
</strike><span style="background: #FFFF00">

</span> <p>or Option 2:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class UserRenamerModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Renamer.class)
         .setBinding().to(ReplacingRenamer.class);
   }
 }</code></pre><strike>
</strike><span style="background: #FFFF00">

</span> With both options, the {@code Optional<Renamer>} will be present and supply <strike>the
</strike><span style="background: #FFFF00">the</span> ReplacingRenamer.<strike> 
 
</strike><span style="background: #FFFF00">

</span> <p>Default values can be supplied using:<strike>
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }</code></pre><strike>
</strike><span style="background: #FFFF00">

</span> With the above module, code can inject an {@code @LookupUrl String} and <strike>it
</strike><span style="background: #FFFF00">it</span> will supply <strike>the</strike><span style="background: #FFFF00">the
</span> DEFAULT_LOOKUP_URL. <strike> </strike>A user can change this value by <strike>binding
</strike><span style="background: #FFFF00">binding

</span> <pre><code>
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setBinding().toInstance(CUSTOM_LOOKUP_URL);
   }
 }</code></pre><strike>
</strike><span style="background: #FFFF00">

</span> ... which will override the default value.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>If one module uses setDefault the only way to override the default is to use setBinding.<strike>
</strike> It <strike>is</strike><span style="background: #FFFF00">is
</span> an error for a user to specify the binding without using OptionalBinder <strike>if
</strike><span style="background: #FFFF00">if</span> setDefault <strike>or</strike><span style="background: #FFFF00">or
</span> setBinding are called. <strike> </strike>For example,<strike> 
</strike><span style="background: #FFFF00">

</span> <pre><code>
 public class FrameworkModule extends AbstractModule {
   protected void configure() {
     OptionalBinder.newOptionalBinder(binder(), Key.get(String.class, LookupUrl.class))
         .setDefault().toInstance(DEFAULT_LOOKUP_URL);
   }
 }
 public class UserLookupModule extends AbstractModule {
   protected void configure() {
     bind(Key.get(String.class, LookupUrl.class)).toInstance(CUSTOM_LOOKUP_URL);
   }<strike> </strike>
 }</code></pre><strike>
</strike><span style="background: #FFFF00">

</span> ... would generate an error, because both the framework and the user are trying to bind
 {@code @LookupUrl String}.<strike> </strike>

 @author sameb@google.com (Sam Berlin)
 @since 4.0</blockquote>
<A NAME="com.google.inject.multibindings.OptionalBinder.dmethod.setBinding()"></A><a href="com.google.inject.multibindings.OptionalBinder.html" class="hiddenlink">Class <b>OptionalBinder</b></a>, <a href="com.google.inject.multibindings.OptionalBinder.html#com.google.inject.multibindings.OptionalBinder.setBinding_changed()" class="hiddenlink">LinkedBindingBuilder&lt;T&gt; <b>setBinding()</b></a><br><br><blockquote>Returns a binding builder used to set the actual value that will be injected.<strike>
</strike> This <strike>overrides</strike><span style="background: #FFFF00">overrides
</span> any binding set by <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#setDefault"><TT>.setDefault</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <strike>
 </strike><p>It is an error to call this method without also calling one of the {@code to}<strike>
</strike> methods on <strike>the</strike><span style="background: #FFFF00">the
</span> returned binding builder.</blockquote>
<A NAME="com.google.inject.multibindings.OptionalBinder.dmethod.setDefault()"></A><a href="com.google.inject.multibindings.OptionalBinder.html" class="hiddenlink">Class <b>OptionalBinder</b></a>, <a href="com.google.inject.multibindings.OptionalBinder.html#com.google.inject.multibindings.OptionalBinder.setDefault_changed()" class="hiddenlink">LinkedBindingBuilder&lt;T&gt; <b>setDefault()</b></a><br><br><blockquote>Returns a binding builder used to set the default value that will be injected.<strike>
</strike> The binding <strike>set</strike><span style="background: #FFFF00">set
</span> by this method will be ignored if <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#setBinding"><TT>.setBinding</TT></A> is called.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>It is an error to call this method without also calling one of the {@code to}<strike>
</strike> methods on <strike>the</strike><span style="background: #FFFF00">the
</span> returned binding builder.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.OptionalBinderBinding!class"></A><a href="com.google.inject.multibindings.OptionalBinderBinding.html" class="hiddenlink">Class <b>OptionalBinderBinding</b></a><br><br><blockquote>A binding for a OptionalBinder.<strike>
 
</strike><span style="background: #FFFF00">

</span> <p>Although OptionalBinders may be injected through a variety of <strike>types
</strike><span style="background: #FFFF00">types</span> {@code T}, {@<strike>code</strike><span style="background: #FFFF00">code
</span> Optional<T>}, {@code Optional<Provider<T>>}, etc..), <strike>an
</strike><span style="background: #FFFF00">an</span> OptionalBinderBinding exists only on <strike>the</strike><span style="background: #FFFF00">the
</span> Binding associated with <strike>the
</strike><span style="background: #FFFF00">the</span> {@code Optional<T>} key. <strike> </strike>Other bindings can be validated to <strike>be</strike><span style="background: #FFFF00">be
</span> derived from <strike>this
</strike><span style="background: #FFFF00">this</span> OptionalBinderBinding using <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/OptionalBinderBinding/.html#containsElement"><TT>.containsElement</TT></A>.<strike>
 
</strike><span style="background: #FFFF00">

</span> @param <T> The fully qualified type of the optional binding, including Optional.<strike>
   </strike> <span style="background: #FFFF00">For</span> <span style="background: #FFFF00">example:
</span>   <strike>For</strike> <strike>example:</strike> {@code Optional<String>}.
 <strike>
 </strike>@since 4.0
 @author sameb@google.com (Sam Berlin)</blockquote>
<A NAME="com.google.inject.multibindings.OptionalBinderBinding.dmethod.containsElement(Element)"></A><a href="com.google.inject.multibindings.OptionalBinderBinding.html" class="hiddenlink">Class <b>OptionalBinderBinding</b></a>, <a href="com.google.inject.multibindings.OptionalBinderBinding.html#com.google.inject.multibindings.OptionalBinderBinding.containsElement_changed(com.google.inject.spi.Element)" class="hiddenlink">boolean <b>containsElement(Element)</b></a><br><br><blockquote>Returns true if this OptionalBinder contains the given Element in order to build the optional
 binding or uses the given Element in order to support building and injecting its data. This
 will work for OptionalBinderBinding retrieved from an injector <strike>and
</strike><span style="background: #FFFF00">and</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>. Usually this is only necessary if you are working with elements
 retrieved from modules (without an Injector), otherwise <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getDefaultBinding"><TT>.getDefaultBinding</TT></A> <strike>and
</strike><span style="background: #FFFF00">and</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/.html#getActualBinding"><TT>.getActualBinding</TT></A> are better options.</blockquote>
<A NAME="com.google.inject.multibindings.OptionalBinderBinding.dmethod.getActualBinding()"></A><a href="com.google.inject.multibindings.OptionalBinderBinding.html" class="hiddenlink">Class <b>OptionalBinderBinding</b></a>, <a href="com.google.inject.multibindings.OptionalBinderBinding.html#com.google.inject.multibindings.OptionalBinderBinding.getActualBinding_changed()" class="hiddenlink">Binding&lt;?&gt; <b>getActualBinding()</b></a><br><br><blockquote>Returns the actual binding (set by <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/OptionalBinder.html#setBinding"><TT>OptionalBinder.setBinding</TT></A>) or null if not set.<strike>
</strike> <strike>This</strike><span style="background: #FFFF00">This
</span> will throw <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/UnsupportedOperationException.html"><TT>UnsupportedOperationException</TT></A> if it is called on an element <strike>retrieved
</strike><span style="background: #FFFF00">retrieved</span> <strike>from</strike><span style="background: #FFFF00">from
</span> <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The Binding's type will always match the type Optional's generic type. For example, <strike>if getKey
</strike><span style="background: #FFFF00">if
 getKey</span> returns a key of <code>Optional&lt;String></code>, then this will always return <strike>a
</strike><span style="background: #FFFF00">a</span> <code><span style="background: #FFFF00">
 </span>Binding&lt;String></code>.</blockquote>
<A NAME="com.google.inject.multibindings.OptionalBinderBinding.dmethod.getDefaultBinding()"></A><a href="com.google.inject.multibindings.OptionalBinderBinding.html" class="hiddenlink">Class <b>OptionalBinderBinding</b></a>, <a href="com.google.inject.multibindings.OptionalBinderBinding.html#com.google.inject.multibindings.OptionalBinderBinding.getDefaultBinding_changed()" class="hiddenlink">Binding&lt;?&gt; <b>getDefaultBinding()</b></a><br><br><blockquote>Returns the default binding (set by <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/OptionalBinder.html#setDefault"><TT>OptionalBinder.setDefault</TT></A>) if one exists or <strike>null
 if</strike><span style="background: #FFFF00">null if
</span> no default binding is set. This will throw <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/UnsupportedOperationException.html"><TT>UnsupportedOperationException</TT></A> if it is
 called on an element retrieved from <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/Elements.html#getElements"><TT>Elements.getElements</TT></A>.<strike>
</strike><span style="background: #FFFF00">

</span> <p><strike>
 </strike>The Binding's type will always match the type Optional's generic type. For example, <strike>if getKey
</strike><span style="background: #FFFF00">if
 getKey</span> returns a key of <code>Optional&lt;String></code>, then this will always return <strike>a
</strike><span style="background: #FFFF00">a</span> <code><span style="background: #FFFF00">
 </span>Binding&lt;String></code>.</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.ProvidesIntoMap!class"></A><a href="com.google.inject.multibindings.ProvidesIntoMap.html" class="hiddenlink">Class <b>ProvidesIntoMap</b></a><br><br><blockquote>Annotates methods of a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoMap/Module.html"><TT>Module</TT></A> to add items to a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoMap/MapBinder.html"><TT>MapBinder</TT></A>.<strike>
</strike> The method's <strike>return</strike><span style="background: #FFFF00">return
</span> type, binding annotation and additional key annotation <strike>determines
</strike><span style="background: #FFFF00">determines</span> what Map this will <strike>contribute</strike><span style="background: #FFFF00">contribute
</span> to. For example,

 <pre>
 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Foo")
 {@literal @}Named("<strike>plugins</strike><span style="background: #FFFF00">urls</span>")
 Plugin provideFooUrl(FooManager fm) { return fm.getPlugin(); }

 {@literal @}ProvidesIntoMap
 {@literal @}StringMapKey("Bar")
 {@literal @}Named("urls")
 Plugin provideBarUrl(BarManager bm) { return bm.getPlugin(); }
 </pre>

 will add two items to the {@code @Named("urls") Map<String, Plugin>} map. The key 'Foo'<strike>
</strike> will <strike>map</strike><span style="background: #FFFF00">map
</span> to the provideFooUrl method, and the key 'Bar' will map to the provideBarUrl method.<strike>
</strike> The <strike>values</strike><span style="background: #FFFF00">values
</span> are bound as providers and will be evaluated at injection time.

 <p>Because the key is specified as an annotation, only Strings, Classes, enums, <strike>primitive
</strike><span style="background: #FFFF00">primitive</span> <strike>types</strike><span style="background: #FFFF00">types
</span> and annotation instances are supported as keys.

 @author sameb@google.com (Sam Berlin)
 @since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.ProvidesIntoOptional!class"></A><a href="com.google.inject.multibindings.ProvidesIntoOptional.html" class="hiddenlink">Class <b>ProvidesIntoOptional</b></a><br><br><blockquote>Annotates methods of a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoOptional/Module.html"><TT>Module</TT></A> to add items to a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoOptional/Multibinder.html"><TT>Multibinder</TT></A>.<strike>
</strike> The method's <strike>return</strike><span style="background: #FFFF00">return
</span> type and binding annotation determines what Optional this <strike>will
</strike><span style="background: #FFFF00">will</span> contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoOptional(DEFAULT)
 {@literal @}Named("url")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoOptional(ACTUAL)
 {@literal @}Named("url")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will set the default value of {@code @Named("url") Optional<String>} to foo's URL,<strike>
</strike> and <strike>then</strike><span style="background: #FFFF00">then
</span> override it to bar's URL.

 @author sameb@google.com (Sam Berlin)
 @since 4.0</blockquote>
<hr align="left" width="100%">
<A NAME="com.google.inject.multibindings.ProvidesIntoSet!class"></A><a href="com.google.inject.multibindings.ProvidesIntoSet.html" class="hiddenlink">Class <b>ProvidesIntoSet</b></a><br><br><blockquote>Annotates methods of a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoSet/Module.html"><TT>Module</TT></A> to add items to a <A HREF="http://google.github.io/guice/api-docs/4.2/javadoc/com/google/inject/multibindings/ProvidesIntoSet/Multibinder.html"><TT>Multibinder</TT></A>.<strike>
</strike> The method's <strike>return</strike><span style="background: #FFFF00">return
</span> type and binding annotation determines what Set this <strike>will
</strike><span style="background: #FFFF00">will</span> contribute to. For example,

 <pre>
 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideFooUrl(FooManager fm) { returm fm.getUrl(); }

 {@literal @}ProvidesIntoSet
 {@literal @}Named("urls")
 String provideBarUrl(BarManager bm) { return bm.getUrl(); }
 </pre>

 will add two items to the {@code @Named("urls") Set<String>} set. The items are bound as
 providers and will be evaluated at injection time.

 @author sameb@google.com (Sam Berlin)
 @since 4.0</blockquote>
<hr align="left" width="100%">

</BODY>
</HTML>
